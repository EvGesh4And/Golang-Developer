# Работа с вводом/выводом

## Цели вебинара

1. Использовать библиотеки ввода-вывода
2. Не пугаться, если библиотека просит какой то Reader вместо `string` или `[]byte`
3. Форматировать строки

## Смысл

1. Связать ваши решения с внешним миром
2. Свободно перемещать данные внутри программы и между ними

## Маршрут вебинара

- Введение в ввод-вывод в Go
- Стандартные интерфейсы: `Reader`, `Writer`, `Closer`
- Блочные устройства, Seeker
- Буферизация ввода/вывода
- Форматированный ввод и вывод: `fmt`
- Работа с командной строкой
- Рефлексия

## Библиотеки, пакеты

- `io` — базовые функции и интерфейсы
- `bufio` — буферизованный ввод/вывод
- `fmt` — форматированный ввод/вывод
- `os` (точнее `os.Open` и `os.File`) — открытие файла

Также, для работы с файловой системой будут полезны:
- `path` и `path/filepath` — для работы с путями к файлам

`ioutil` — устарел в 1.16 —> `io`, `os`

## Проблема унификафии

- Устройств ввода-вывода — много
- Хотим писать код, не зависящий от конкректного устройства

Путь: `Dependency Injection (DI)`


**Dependency Injection (DI)** — это паттерн проектирования, который позволяет управлять зависимостями между компонентами системы, передавая их извне вместо создания внутри.
- Преимущества DI
Снижение связности (Loose Coupling) – компоненты становятся независимыми друг от друга.
- Упрощение тестирования – можно легко заменять зависимости заглушками (mock).
- Гибкость – можно подменять зависимости без изменения кода клиента.
- Упрощение поддержки и расширяемости – код становится более модульным.


## Абстракция устройства ввода-вывода

Устройств ввода-вывода – много. У каждого свои особенности.

У каждого устройства есть свой пакет с <span style="color: red;">**имплементацией**</span> (реализацией):

*память, файл, сеть, пользователь + любые ваши*

Чтобы работать одинаково – go предоставляет <span style="color: green;">**интерфейсы**</span>;

Каждый <span style="color: green;">**интерфейс**</span> представляет одну "фичу" (возможность) устройства;
Каждая <span style="color: red;">**имплементация**</span> реализует набор фич.

![alt text](image.png)

## Пакет `io`

Содержит <span style="color: green;">**интерфейсы**</span> и инструменты для работы с ними.

Не привязан ни к каким <span style="color: red;">**имплементациям**</span> (таким как `ос`, файлы, сокеты и т.п.).

### Обзор <span style="color: green;">**интерфейсов**</span>

**Основные**
|Чтение         |Запись         |Комментарий        |
|------         |------         |-----------        |
|`Reader `      |`Writer`       |массив байт        |
|`ByteReader`   |`ByteWriter`   |байты по 1         |
|`ReaderAt`     |`WriterAt`     |пропуски           |
|`ReaderFrom`   |`WriteTo`      |в другой интерфейс |
|`RuneReader`   |`StringWriter` |                   |
|`ByteScanner`  |               |                   |
|`RuneScaner`   |               |                   |

**Составные**
- `ReadCloser`
- `ReadSeekCloser`
- `ReadSeeker`
- `ReadWriteCloser`
- `ReadWriteSeeker`
- `ReadWriter`
- `WriteCloser`
- `WriteSeeker`

**Другое**
- `Closer`
- `Seeker`

### Как кто работает

```go
func main() {
    inFile, err := os.Open("filename.in"); check(err)
    outFile, err := os.Create("filename.io"); check(err)
    process(inFile, outFile)        // (1)

    inMem := bytes.NewReader([]byte("some content"))
    outMem := bytes.NewBuffer(nil)
    process(inMem, outMem)          // (2)

    process(os.Stdin, os.Stdout)    // (3)

    process(inFile, outMem)         // (4)
}
```

```go
func process(
    in io.Reader,
    out io.Writer,
) {
    data := make([]byte, 1024)

    _, err := in.Read(data)
    check(err)

    callLogic(data)

    _, err = out.Write(data)
    check(err)
}
```

### `io.Reader`

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

`io.Reader` — это нечто, **ИЗ** чего можно последовательно читать байты.

- Метод `Read` читает данные (из объекта) в буфер `p`, не более чем `len(p)` байт.
- Метод `Read` возвращает количество байт `n`, которые были прочитаны и записаны в `p`, причем `n` может быть меньше `len(p)`.
- Метод `Read` возвращает ошибку или `io.EOF` в случае конца файла, при этом он так же может вернуть `n > 0`, если часть данных были прочитаны до ошибки.

`io.EOF` - специальная ошибка, означаюшая что мы достигли конца потока (файла)

#### Из исходников Go
`Reader` — это интерфейс, который включает в себя базовый метод `Read`.

`Read` читает до `len(p)` байтов в `p`. Он возвращает количество прочитанных байтов `(0 <= n <= len(p))` и любую возникшую ошибку. Даже если `Read` возвращает `n < len(p)`, он может использовать весь `p` как рабочее пространство во время вызова.

Если доступны некоторые данные, но их меньше, чем `len(p)` байтов, `Read` обычно возвращает доступные данные вместо ожидания большего объема.

Если `Read` сталкивается с ошибкой или концом файла после успешного чтения `n > 0` байтов, он возвращает количество прочитанных байтов. Он может вернуть (ненулевую) ошибку в том же вызове или вернуть ошибку (и `n == 0`) при следующем вызове.

Один из примеров этого общего случая: `Reader`, возвращающий ненулевое количество байтов в конце входного потока, может вернуть либо `err == EOF`, либо `err == nil`. Следующий вызов Read должен вернуть `0, EOF`.

Вызывающие стороны всегда должны обрабатывать `n > 0` возвращенных байтов перед тем, как рассматривать ошибку `err`. Такой порядок действий правильно обрабатывает ошибки ввода-вывода, возникающие после чтения некоторых байтов, а также оба допустимых поведения `EOF`.

Если `len(p) == 0`, `Read` всегда должен возвращать `n == 0`. Он может вернуть
ненулевую ошибку, если известны какие-либо условия ошибки, например `EOF`. 

Реализациям `Read` не рекомендуется возвращать нулевое количество байтов с nil-ошибкой, за исключением случая, когда `len(p) == 0`. Вызывающие стороны должны интерпретировать возвращение `0` и `nil` как указание на отсутствие действий; в частности, это не означает `EOF`.

Реализации не должны сохранять ссылку на `p`.

### `io.Writer`

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

`io.Writer` – это нечто, ВО что можно последовательно записать байты.
- Метод `Write` записывает `len(p)` байт из `p` в объект (например файл или сокет).
- Метод `Write` реализует цикл до-записи внутри себя.
- Метод `Write` возвращает количество записанных байт `n` и ошибку, если `n < len(p)`

### `io.Closer`

```go
type Closer interface {
    Close() error
}
```

`io.Closer` — представляет ресурс, который следует вручную освободить после использования
- Если библиотека передала вам объект, поддерживающий `Closer` —
значит библиотека ожидает что вы сами вызовете `Close`;
- Если вы передаёте свой объект в функцию, принимаĀûуĀ Closer
ожидайте ùто его там закроĀт;
- Close следует вýзýватþ как можно ранþúе;
- Close ùасто вýзýваĀт в блоке defer f.Close() (забýваā при ÿтом обработатþ оúибку);
- Забýтýй Close - приùина утеùки ресурсов (например, навеùно открýтýй файл)
Осталþнýе интерфейсý пакета io рассмотрим позже