# Работа с вводом/выводом

## Цели вебинара

1. Использовать библиотеки ввода-вывода
2. Не пугаться, если библиотека просит какой то `Reader` вместо `string` или `[]byte`
3. Форматировать строки

## Смысл

1. Связать ваши решения с внешним миром
2. Свободно перемещать данные внутри программы и между ними

## Маршрут вебинара

- Введение в ввод-вывод в Go
- Стандартные интерфейсы: `Reader`, `Writer`, `Closer`
- Блочные устройства, `Seeker`
- Буферизация ввода/вывода
- Форматированный ввод и вывод: `fmt`
- Работа с командной строкой
- Рефлексия

## Библиотеки, пакеты

- `io` — базовые функции и интерфейсы
- `bufio` — буферизованный ввод/вывод
- `fmt` — форматированный ввод/вывод
- `os` (точнее `os.Open` и `os.File`) — открытие файла

Также, для работы с файловой системой будут полезны:
- `path` и `path/filepath` — для работы с путями к файлам

`ioutil` — устарел в 1.16 —> `io`, `os`

## Проблема унификафии

- Устройств ввода-вывода — много
- Хотим писать код, не зависящий от конкректного устройства

Путь: `Dependency Injection (DI)`


**Dependency Injection (DI)** — это паттерн проектирования, который позволяет управлять зависимостями между компонентами системы, передавая их извне вместо создания внутри.

**Преимущества DI**

- Снижение связности (Loose Coupling) – компоненты становятся независимыми друг от друга.
- Упрощение тестирования – можно легко заменять зависимости заглушками (mock).
- Гибкость – можно подменять зависимости без изменения кода клиента.
- Упрощение поддержки и расширяемости – код становится более модульным.


## Абстракция устройства ввода-вывода

Устройств ввода-вывода – много. У каждого свои особенности.

У каждого устройства есть свой пакет с <span style="color: red;">**имплементацией**</span> (реализацией):

*память, файл, сеть, пользователь + любые ваши*

Чтобы работать одинаково – go предоставляет <span style="color: green;">**интерфейсы**</span>;

Каждый <span style="color: green;">**интерфейс**</span> представляет одну "фичу" (возможность) устройства;
Каждая <span style="color: red;">**имплементация**</span> реализует набор фич.

![alt text](image.png)

## Пакет `io`

Содержит <span style="color: green;">**интерфейсы**</span> и инструменты для работы с ними.

Не привязан ни к каким <span style="color: red;">**имплементациям**</span> (таким как `ос`, файлы, сокеты и т.п.).

#### Из исходников Go
Пакет `io` предоставляет базовые интерфейсы для I/O-примитивов.
Его основная задача — **оборачивать** существующие реализации таких примитивов, например, из пакета `os`, в общие публичные интерфейсы, абстрагирующие функциональность, а также некоторые другие связанные примитивы.

Поскольку эти интерфейсы и примитивы оборачивают низкоуровневые операции с различными реализациями, если не указано иное, клиенты не должны предполагать, что они безопасны для параллельного выполнения.

### Обзор <span style="color: green;">**интерфейсов**</span>

**Основные**
|Чтение         |Запись         |Комментарий        |
|------         |------         |-----------        |
|`Reader `      |`Writer`       |массив байт        |
|`ByteReader`   |`ByteWriter`   |байты по 1         |
|`ReaderAt`     |`WriterAt`     |пропуски           |
|`ReaderFrom`   |`WriteTo`      |в другой интерфейс |
|`RuneReader`   |`StringWriter` |                   |
|`ByteScanner`  |               |                   |
|`RuneScaner`   |               |                   |

**Составные**
- `ReadCloser`
- `ReadSeekCloser`
- `ReadSeeker`
- `ReadWriteCloser`
- `ReadWriteSeeker`
- `ReadWriter`
- `WriteCloser`
- `WriteSeeker`

**Другое**
- `Closer`
- `Seeker`

### Как кто работает

```go
func main() {
    inFile, err := os.Open("filename.in"); check(err)
    outFile, err := os.Create("filename.io"); check(err)
    process(inFile, outFile)        // (1)

    inMem := bytes.NewReader([]byte("some content"))
    outMem := bytes.NewBuffer(nil)
    process(inMem, outMem)          // (2)

    process(os.Stdin, os.Stdout)    // (3)

    process(inFile, outMem)         // (4)
}
```

```go
func process(
    in io.Reader,
    out io.Writer,
) {
    data := make([]byte, 1024)

    _, err := in.Read(data)
    check(err)

    callLogic(data)

    _, err = out.Write(data)
    check(err)
}
```

### `io.Reader`

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

`io.Reader` — это нечто, **ИЗ** чего можно последовательно читать байты.

- Метод `Read` читает данные (из объекта) в буфер `p`, не более чем `len(p)` байт.
- Метод `Read` возвращает количество байт `n`, которые были прочитаны и записаны в `p`, причем `n` может быть меньше `len(p)`.
- Метод `Read` возвращает ошибку или `io.EOF` в случае конца файла, при этом он так же может вернуть `n > 0`, если часть данных были прочитаны до ошибки.

`io.EOF` - специальная ошибка, означаюшая что мы достигли конца потока (файла)

#### Из исходников Go
`Reader` — это интерфейс, который включает в себя базовый метод `Read`.

`Read` читает до `len(p)` байтов в `p`. Он возвращает количество прочитанных байтов `(0 <= n <= len(p))` и любую возникшую ошибку. Даже если `Read` возвращает `n < len(p)`, он может использовать весь `p` как рабочее пространство во время вызова.

Если доступны некоторые данные, но их меньше, чем `len(p)` байтов, `Read` обычно возвращает доступные данные вместо ожидания большего объема.

Если `Read` сталкивается с ошибкой или концом файла после успешного чтения `n > 0` байтов, он возвращает количество прочитанных байтов. Он может вернуть (ненулевую) ошибку в том же вызове или вернуть ошибку (и `n == 0`) при следующем вызове.

Один из примеров этого общего случая: `Reader`, возвращающий ненулевое количество байтов в конце входного потока, может вернуть либо `err == EOF`, либо `err == nil`. Следующий вызов Read должен вернуть `0, EOF`.

Вызывающие стороны всегда должны обрабатывать `n > 0` возвращенных байтов перед тем, как рассматривать ошибку `err`. Такой порядок действий правильно обрабатывает ошибки ввода-вывода, возникающие после чтения некоторых байтов, а также оба допустимых поведения `EOF`.

Если `len(p) == 0`, `Read` всегда должен возвращать `n == 0`. Он может вернуть
ненулевую ошибку, если известны какие-либо условия ошибки, например `EOF`. 

Реализациям `Read` не рекомендуется возвращать нулевое количество байтов с nil-ошибкой, за исключением случая, когда `len(p) == 0`. Вызывающие стороны должны интерпретировать возвращение `0` и `nil` как указание на отсутствие действий; в частности, это не означает `EOF`.

Реализации не должны сохранять ссылку на `p`.

### `io.Writer`

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

`io.Writer` — это нечто, ВО что можно последовательно записать байты.
- Метод `Write` записывает `len(p)` байт из `p` в объект (например файл или сокет).
- Метод `Write` реализует цикл до-записи внутри себя.
- Метод `Write` возвращает количество записанных байт `n` и ошибку, если `n < len(p)`

#### Из исходников Go

`Writer` — это интерфейс, который включает базовый метод `Write`.

`Write` записывает `len(p)` байт из `p` в нижележащий поток данных.

Он возвращает количество записанных байт из `p` `(0 <= n <= len(p))`
и любую ошибку, которая привела к досрочному завершению записи.

`Write` должен возвращать ненулевую ошибку, если `n < len(p)`.

`Write` не должен изменять данные в срезе, даже временно.
Реализации не должны сохранять `p`.


### `io.Closer`

```go
type Closer interface {
    Close() error
}
```

`io.Closer` — представляет ресурс, который следует вручную освободить после использования
- Если библиотека передала вам объект, поддерживающий `Closer`
    - значит библиотека ожидает что вы сами вызовете `Close`;
- Если вы передаёте свой объект в функцию, принимающую `Closer`
    - ожидайте что его там закроют;
- `Close` следует вызывать как можно раньше;
- `Close` часто вызывают в блоке `defer f.Close()` (забывая при этом обработать ощибку);
- Забытый `Close` - причина утечки ресурсов (например, навечно открытый файл)

Остальные интерфейсы пакета `io` рассмотрим позже

#### Из исходников Go

`Closer` — это интерфейс, который включает базовый метод `Close`.

Поведение `Close` после первого вызова не определено.
Конкретные реализации могут документировать свое поведение.

## Работа с файлами (... и последовательный доступ)

### Открываем файлы (общий случай)

Для открытия файла на чтение используем `os.OpenFile`

```go
var file *os.File // файловый дескриптор в Go
file, err := os.OpenFile(path, os.O_RDWR, 0644)
if err != nil {
    if os.IsNotExist(err) {
        // файл не найден ...
    }
    // другие ошибки, например нет прав ...
}
defer file.Close()
```

#### Из исходников Go

`OpenFile` — это обобщённый вызов открытия файла;
большинство пользователей предпочтут использовать `Open` или `Create`.

Он открывает указанный файл с заданным флагом (например, `O_RDONLY` и т. д.).

Если файл не существует и передан флаг `O_CREATE`, он создаётся с правами доступа `perm` (до применения umask).

В случае успешного выполнения методы возвращённого объекта `File` могут использоваться для ввода-вывода.

В случае ошибки она будет представлена типом `*PathError`.


### Специальные "сокращения"

#### Open

```go
os.Open(name) = OpenFile(name, os.O_RDONLY, 0)
```

#### Из исходников Go
`Open` открывает указанный файл для чтения. 
В случае успешного выполнения методы возвращённого файла могут использоваться для чтения; связанный файловый дескриптор имеет режим `O_RDONLY`.

В случае ошибки она будет представлена типом `*PathError`.

#### Create
```go
os.Create(name) = OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
```

#### Из исходников Go

`Create` создаёт или обрезает указанный файл. 
Если файл уже существует, его содержимое **обнуляется**. 
Если файл не существует, он создаётся с правами `0o666` (до применения umask).
В случае успешного выполнения методы возвращённого объекта `File` могут использоваться для ввода-вывода; связанный файловый дескриптор имеет режим `O_RDWR`.
В случае ошибки она будет представлена типом `*PathError`.

### Интерфейсы os.File

```go
Reader
ReaderAt
ReaderFrom

Writer
WriterAt
StringWriter

Seeker
Closer (!)
```


### Чтение файла

Читаем первые `N` байт в `buf`, используя `io.Reader`

```go
 N := 1024 // мы заранее знаем сколько хотим прочитать
 buf := make([]byte, N) // подготавливаем буфер нужного размера
 file, _ := os.Open(path) // открываем файл (не забыть про err!)
 offset := 0
 for offset < N {
    read, err := file.Read(buf[offset:])
    offset += read
    if err == io.EOF {
        // что если не дочитали ?
        break
    }
    if err != nil {
        log.Panicf("failed to read: %v", err)
    }
 }
```

#### Удобства для чтения

Гарантированно заполнить буфер
```go
b := make([]byte, 1024*1024)
file, _ := os.Open(path)
read, err := io.ReadFull(file, b) // содержит цикл внутри
```
Прочитать все до конца файла
```go
file, _ := os.Open(path)
b, err := io.ReadAll(file) // err настоящая ошибка, не EOF
```

Или еще короче (для скриптов)
```go
b, err := os.ReadFile(path) // прочитать весь файл по имени
```
операции в пакете `io` применимы к любым `io.Reader`, а не только файлам

### Пишем в файлы

Пишем содержимое `b` в файл используя `io.Writer`

```go
b := make([]byte, 1024*1024) // заполнен нулями
file, _ := os.Create(path)
written, err := file.Write(b)

if err != nil {
    log.Panicf("failed to write: %v", err)
}
// мы записали 1M данных !
file.Close() // чтобы очистить буферы ОС
```
В отличие от операции чтения, тут цикл не нужен.

#### Удобства для записи

Целиком переписать файл:

```go
b := make([]byte, 1024*1024)
err := os.WriteFile(path, b, 0644)
```

Скопировать данные из любого `io.Reader`:

```go
f, _ := os.Create("tmp")
w, _ := io.Copy(f, os.Stdin) // в f из Stdin, свой цикл внутри и буффер
fmt.Printf("Written %v bytes", w)
```

`Copy` остановится на `io.EOF`, 
- есть ещё `CopyN` — он остановится через `N` байт;
- а еще `CopyBuffer` - он не создаёт свой буфер, а использует заданный.

операции в пакете `io` применимы к любым `io.Writer`, а не только файлам

## Произвольный доступ (... и работа с файлами)

Устройства/технологии ввода/вывода данных можно условно разделить на 

- поддерживающие <span style="color: green;">**произвольный**</span> доступ
  - жесткие диски памяти
-  и поддерживающие <span style="color: blue;">**последовательный**</span> доступ
   - терминал сетевое соединение pipe

Рассмотренные `io.Reader`, `io.Writer` — для <span style="color: blue;">**последовательного**</span> доступа, а вот `io.ReaderAt`, `io.WriterAt`, `io.Seeker` — для <span style="color: green;">**произвольного**</span> доступа

### `io.Seeker`

```go
type Seeker interface {
    Seek(offset int64, whence int) (int64, error)
}
```

Позволяет **передвинуть текущую "позицию" в файле вперед или назад с определенной точки `whence` на `offset` байт**.
Аналог в линуксе — man lseek

Возможные значения `whence`:
- `io.SeekStart = 0` относительно начала файла;
- `io.SeekCurrent = 1` относительно текущего положения в файле;
- `io.SeekEnd = 2` относительно конца файла.

Тип `os.File` реализует интерфейс `io.Seeker`, а вот типа `net.TCPConn` — нет.

```go
f.Seek(0, io.SeekStart)     // начало файла
f.Seek(1, io.SeekCurrent)   // пропустить следующий байт
f.Seek(-1, io.SeekEnd)      // последний байт
```

### `io.ReaderAt` и `io.WriterAt`

```go
type ReaderAt interface {
    ReadAt(p []byte, off int64) (n int, err error)
}

type WriterAt interface {
    WriteAt(p []byte, off int64) (n int, err error)
}
```
Позволяют прочитать/записать `len(p)` байт с указанным `off` смещением в файле, т.е. с произвольной позиции

В отличие от `io.Reader`, реализации `io.ReaderAt` всегда читают ровно `len(p)` байт или возвращают ошибку.

## Другие инструменты

### ` io.WriterTo` и `io.ReaderFrom`

```go
type ReaderFrom interface {
    ReadFrom(r Reader) (n int64, err error)
 }

 type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
 }
 ```
При копировании с использованием `io.Reader` и `io.Writer` приходится выделять буфер в памяти,  т.е. происходит двойное копирование данных.

Если же источник/получатель данных реализуют интерфейсы `io.WriterTo` / `io.ReaderFrom`, то копирование с помощью `io.Copy` может использовать оптимизацию и **НЕ** выделять промежуточный буфер.

Используются в `io.Copy` автоматически

Например, в linux есть специальный системный вызов `sendfile` для быстрого копирования — и реализация этих интерфейсов позволяет использовать его вместо побайтового переноса данных.

#### Из исходников Go

`ReaderFrom` — это интерфейс, который определяет метод `ReadFrom`.

`ReadFrom` читает данные из `r` до достижения конца файла (EOF) или ошибки.
Возвращаемое значение `n` — количество прочитанных байтов.
Любая ошибка (кроме EOF), возникшая во время чтения, также возвращается.

Функция `Copy` использует `ReaderFrom`, если он доступен.

`WriterTo` — это интерфейс, определяющий метод `WriteTo`.

`WriteTo` записывает данные в `w`, пока они не закончатся или не возникнет ошибка.
Возвращаемое значение `n` — количество записанных байтов.
Любая ошибка, возникшая во время записи, также возвращается.

Функция `Copy` использует `WriterTo`, если он доступен.

### Комбинированные интерфейсы

```go
type ReadCloser interface {
    Reader
    Closer
 }
 func FooRead(src io.ReadCloser){
    src.Read(...)
    src.Close()
 }
 ```

Eсли в вашем коде требуется объект с несколькими фичами — вы можете использовать комбинированные интерфейсы. 
Все практичные комбинации уже есть в пакете `io`

### Объединение потоков, chaining

`io.MultiReader` — позволяет последовательно читать из нескольких `reader`-ов.
 По смыслу аналогично `cat file1 file2 file3`

```go
func MultiReader(readers ...Reader) Reader
```

`io.MultiWriter` — позволяет записывать в несколько `writer`-ов.
Аналогично `tee file1 file2 file3`

`io.LimitReader` — создаёт новый ридер, который прочитает не более `n` байт, далее вернёт `io.EOF`

```go
func LimitReader(r Reader, n int64) Reader
```
## IO в память

`bytes.Buffer` — позволяет читать и писать в память в последовательном стиле

```go
buf := bytes.NewBuffer(nil)
buf.Write([]byte{55, 56, 57})
buf.Read(...)
contents := buf.String()
```

`bytes.Reader` — позволяет только чтение, зато произвольный доступ

```go
reader := bytes.NewReader([]byte("my data"))
reader.Seek(-1, io.SeekEnd)
reader.Read(...)
```

### Из исходников Go

```go
func (b *Buffer) Write(p []byte) (n int, err error) {
    ...
}
```

`Write` добавляет содержимое `p` в буфер, увеличивая буфер при необходимости.
Возвращаемое значение `n` равно длине `p`; `err` всегда равен `nil`.
Если буфер становится слишком большим, `Write` вызывает панику с [ErrTooLarge].

```go
func (b *Buffer) Read(p []byte) (n int, err error) {
	...
}
```

`Read` читает следующие `len(p)` байтов из буфера или до его опустошения.
Возвращаемое значение `n` — количество прочитанных байтов.
Если в буфере нет данных для чтения, возвращается ошибка [`io.EOF`]
(если только `len(p)` не равен нулю); в остальных случаях ошибка равна `nil`.

### Различия между bytes.NewBuffer и bytes.NewReader

**bytes.NewBuffer (изменяемый)**

```go
buf := bytes.NewBuffer([]byte{})
buf.WriteString("добавить данные")
```

- **Для чтения и записи**

- Автоматически расширяется

- Реализует: `io.Writer`, `io.Reader`

- Использование:
  - Построчная обработка
  - Накопление данных
  - Буферизированный ввод-вывод
  
**bytes.NewReader (только чтение)**

```go
r := bytes.NewReader([]byte{1,2,3})
r.Read(buf)
```
- **Только для чтения**
- Фиксированный размер
- Реализует: `io.Reader`, `io.Seeker`, `io.ReaderAt`
- Использование:
  - Чтение конфигураций
  - Тестовые данные
  - API требующие `io.Reader`

`Buffer` — когда нужно собирать данные, `Reader` — когда работаем с готовыми данными.

**Основные отличия**

|Особенность	| Buffer	| Reader    |
|---------------|-----------|-----------|
|Запись|                 ✅|         ❌|
|Изменение размера|      ✅|         ❌|
|Произвольный доступ|    ❌|         ✅|
|Потокобезопасность|     ❌|         ✅|

Пакет `strings` также предлагает `Reader`, более адаптированный для строк

```go
sr := strings.NewReader()
```

А `strings.Builder` реализует `io.Writer` и другие интерфейсы.

```go
b := strings.Builder{}
```

Если какая то библиотека принимает интерфейсы пакета `io`, а вам надо просто передать туда слайс или строку, используйте эти инструменты

 Пример:

 ```go
 import "bytes"
 import "archive/zip"
 
 buf := bytes.NewBuffer([]byte{})
 zipper := zip.NewWriter(buf)
 _, err := zipper.Write(data)
 // в buf находится zip архив!
```

Как передавать данные через `io`-интерфейсы

1. Для строк (`string`) → `io.Reader`:
```go
import "strings"

data := "текстовые данные"
reader := strings.NewReader(data) // Реализует io.Reader, io.Seeker
```

2. Для слайсов байт (`[]byte`) → `io.Reader`:
```go
import "bytes"

data := []byte{1, 2, 3}
reader := bytes.NewReader(data) // Реализует io.Reader, io.ReaderAt, io.Seeker
```
3. Для записи (`io.Writer`) в буфер:
```go
buf := new(bytes.Buffer) // Пустой буфер (реализует io.Writer)
_, err := buf.Write([]byte("записываем данные"))
```

**Когда что использовать**:

|  Тип данных  |   Конвертер        |   Реализуемые интерфейсы   |
|--------------|---------------     |----------------------------|
|    string    | `strings.NewReader`  | `io.Reader`, `io.Seeker`   |
|    [ ]byte    | `bytes.Reader`       | `io.Reader`, `io.Seeker`, `io.ReaderAt`   |
|(куда писать)  | `bytes.Buffer`    | `io.Writer`, `io.Reader` (для чтения записанного)|

## Буферизация

С помощью пакета `bufio` можно 
- сократить число системных вызовов и 
- улучшить производительность 
в случае, если требуется читать/записывать данные небольшими кусками, например по строкам. 

Буферизованная запись:

```go
file, _ := os.Create(path)
bw := bufio.NewWriter(file)
written, err := bw.Write([]byte("some bytes"))
bw.WriteString("some string")
bw.WriteRune('±')
bw.WriteByte(42)
bw.Flush()   
// очистить буфер, записать все в file
```

Чтение:
```go
file, _ := os.Open(path)
br := bufio.NewReader(file)
line, err := br.ReadString(byte('\n'))
b, err := br.ReadByte()
br.UnreadByte()  // иногда полезно при анализе строки
```

### Из исходников Go

`NewWriter` возвращает новый [`Writer`] с буфером стандартного размера. Если переданный `io.Writer` уже является [Writer] с достаточно большим размером буфера, возвращается исходный [`Writer`].

`NewReader` возвращает новый [`Reader`] с буфером стандартного размера.

## Форматированный ввод-вывод

### Пакет fmt. Вывод

Пакет предоставляет возможности форматированного вывода.
Основные функции:

```go
func Fprintf(w io.Writer, format string, a ...ant) (n int, err error)
func Sprintf(format string, a ...any) string
func Printf(format string, a ...ant) (n int, err error)
```

[Пример](https://go.dev/play/p/zzPQIa7yfVG):
```go
m := map[string]int{"qwe": 1}
fmt.Printf("%s %x \n %#v \n %[3]v", "string", 42, m)
```
#### Основное

**Общие**
| Спецификатор | Описание|
|-------|---------|
|`%v`   | представление по  умолчанию для типа      |
|`%#v`  | вывести как Go код (удобно для структур)  |
|`%T`   | вывести тип переменной                    |
|`%%`   | вывести символ %                          |

**Для целых**

| Спецификатор | Описание|
|-------|---------  |
|`%b`   |    base 2 |
|`%d`  |   base 10  |
|`%o`   | base 8    |
|`%x`   |  base 16  |

**Для строк**

| Спецификатор | Описание|
|-------|---------  |
|`%s`   |  выводит неинтерпретированные байты строки или среза байтов. Если передать срез байтов, Go попытается преобразовать его в строку |
|`%q`  |   выводит строку в двойных кавычках, безопасно экранируя специальные символы в соответствии с синтаксисом Go  |
|`%x`   |  выводит строку или срез байтов в шестнадцатеричном формате, используя две строчные буквы (hex) на байт |

[Документация](https://pkg.go.dev/fmt)


#### Сложные типы

Адрес в памяти: `%p`

Представление по-умолчанию: `%v`

|   Тип     |   Пример                  |
| `struct`  |   `{field0 field1 ...}`   |
|  `array`, `slice` |   `[elem0, elem1, ...]` |
|  `maps`   |   `&{}, &[], &map[]` |

Go представление: `%#v`

[Пример](https://go.dev/play/p/Q2nl9ZnaF96)
```go
arr := []int{1, 2, 3}
mp := map[string]string{"qwe": "asd"}
ch := make(chan int, 3)

var st struct {
	s string
	i int
}

fmt.Printf("%p\n%v\n%#v\n\n", arr, arr, arr)
fmt.Printf("%p\n%v\n%#v\n\n", mp, mp, mp)
fmt.Printf("%p\n%v\n%#v\n\n", ch, ch, ch)
fmt.Printf("%v\n%#v\n\n", st, st)
```

#### Пользовательские типы

Вы можете управлять строковым представлением (`%s`) вашего типа, реализовав интерфейс `fmt.Stringer`

```go
type Stringer interface {
    String() string
}
```

Также можно управлять расширенным представлением (`%#v`), реализовав `GoStringer`

```go
type GoStringer interface {
    GoString() string
}
```
[Пример](https://go.dev/play/p/AvlsmhiXtXv)

```go
type Person struct {
	FirstName string
	LastName  string
	secret    string
}

// uncomment this and see how output changes:
func (p Person) String() string {
	return fmt.Sprintf("%s %s", p.FirstName, p.LastName)
}

// then, uncomment this:
func (p Person) GoString() string {
	return "The Force"
}

func main() {
	p := Person{"Luke", "Skywalker", "JaJa"}
	fmt.Printf("Hello, %v\n", p)
	fmt.Printf("Hello, reference for %v\n", &p)
	fmt.Printf("This is %s's code: %#[1]v\n", p)
	fmt.Println("Hello, ", p, " from println")

	ps := []Person{p, Person{"Obi-Wan", "Kenobi", "ghost"}}
	fmt.Printf("It works in collections too: %v\n", ps)
}
```

#### DeepSeek

В Go "**Go-синтаксис значения**" (форматный спецификатор `%#v`) означает представление значения в таком виде, чтобы его можно было буквально использовать в коде на Go.

Что делает `%#v`?
- Для базовых типов (`int`, `string`, `bool` и т. д.) выводит значение в корректном литеральном виде.

- Для составных типов (`struct`, `slice`, `map`) выводит полное представление с типами, включая имена полей структур.

- Для строк добавляет кавычки ("), для рун — одинарные ('), для указателей — адрес в формате `&value`.

В Go спецификатор `%v` в функциях форматированного вывода (например, `fmt.Printf`, `fmt.Sprintf`) используется для универсального вывода значений в "естественном" формате. Он автоматически выбирает подходящее представление для разных типов данных.

В Go спецификатор `%s` используется для форматированного вывода строк (тип `string`) в функциях пакета `fmt`, таких как `Printf`, `Sprintf`, `Fprintf` и других.


#### Ввод

Также с помошью `fmt` можно считывать данные в заранее известном формате.

Основные функции:

```go
func Scanf(format string, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

Например

```go
var s string
var d int64
fmt.Scanf("%s %d", &s, &d)
```

В функцию `Scanf` передаются указатели, а не сами переменные. 
`Scanf` возврашает количество аргументов, которые удалось сканировать и ошибку, если удалось меньше ожидаемого.



## Командная строка

Аргументы командной строки — простой слайс строк. В Go он доступен как `os.Args`

```bs
$ myprog in=123 out 456 qw
```

В слайсе `os.Args` будет:
```go
["myprog", " in=123", " out", "456", "qwe"]
```

В `os.Args[0]` — всегда имя исполняемого файла

Для упрощения работы с командной строкой можно использовать пакет `flag`

```go
import "flag"
var input string
var offset int
func main() {

flag.StringVar(&input, "input", "", "file to read from")
flag.IntVar(&offset, "offset", 0, "offset in input file")

flag.Parse() // проанализировать аргументы

// теперь в input и offset есть значения
```

### Пакет `flag` в Go

Пакет `flag` в Go предоставляет простой способ обработки аргументов командной строки. Это стандартный пакет, который входит в состав языка, поэтому не требует дополнительной установки.

**Основные возможности**

1. **Определение флагов**: поддержка строковых, числовых и булевых флагов
2. **Автоматическая генерация справки**: флаг `-h` или `-help`
3. **Парсинг аргументов**: разбор переданных аргументов командной строки

**Основные типы флагов**

- `flag.Bool` - булевы флаги (true/false)
- `flag.Int` - целочисленные значения
- `flag.Float64` - числа с плавающей точкой
- `flag.String` - строковые значения
- `flag.Duration` - временные интервалы

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	// Определение флагов
	host := flag.String("host", "localhost", "Server host")
	port := flag.Int("port", 8080, "Server port")
	debug := flag.Bool("debug", false, "Enable debug mode")

	// Парсинг аргументов
	flag.Parse()

	// Использование значений
	fmt.Printf("Starting server on %s:%d (debug: %v)\n", *host, *port, *debug)
}
```

Альтернативный стиль определения флагов

```go
var (
	host  string
	port  int
	debug bool
)

func init() {
	flag.StringVar(&host, "host", "localhost", "Server host")
	flag.IntVar(&port, "port", 8080, "Server port")
	flag.BoolVar(&debug, "debug", false, "Enable debug mode")
}

func main() {
	flag.Parse()
	fmt.Printf("Starting server on %s:%d (debug: %v)\n", host, port, debug)
}
```


**Особенности**
1. Флаги можно передавать в любом порядке
2. Булевы флаги можно передавать в сокращенной форме:
    - `-debug` эквивалентно `-debug=true`
    - `-debug=false` для отключения
3. После флагов можно передавать позиционные аргументы, доступные через `flag.Args()`

Вот простой и практический пример использования пакета `flag` в Go:

```go
package main

import (
	"flag"
	"fmt"
	"strings"
)

func main() {
	// Определяем флаги
	wordPtr := flag.String("word", "default", "слово для вывода")
	numPtr := flag.Int("num", 42, "число для вывода")
	boolPtr := flag.Bool("fork", false, "булев флаг")

	// Альтернативный способ определения флага
	var svar string
	flag.StringVar(&svar, "svar", "default", "строковая переменная")

	// Парсим аргументы командной строки
	flag.Parse()

	// Выводим результаты
	fmt.Println("word:", *wordPtr)
	fmt.Println("num:", *numPtr)
	fmt.Println("fork:", *boolPtr)
	fmt.Println("svar:", svar)
	fmt.Println("tail:", flag.Args())
}
```

**Как использовать**:
1. Сохраните код в файл `main.go`
2. Соберите программу: `go build main.go`
3. Запустите с разными аргументами:

```bs
# Простой запуск
./main

# С флагами
./main -word=hello -num=99 -fork -svar=test arg1 arg2

# Сокращенная форма (только для булевых флагов)
./main -fork

# Справка
./main -h
```

Пример вывода при запуске `./main -word=hello -num=99 -fork -svar=test arg1 arg2`:

```bs
word: hello
num: 99
fork: true
svar: test
tail: [arg1 arg2]
```

**Ключевые моменты**:
1. Флаги можно указывать в любом порядке
2. Булевы флаги (`-fork`) не требуют значения
3. Все аргументы после флагов попадают в `flag.Args()`

Флаг `-h` или `-help` выводит автоматически сгенерированную справку

Этот пример демонстрирует все основные возможности пакета .`flag` для работы с аргументами командной строки.

#### Флаг `-h` (или `-help`)

Флаг `-h` (или `-help`) в Go-программах, использующих пакет `flag`, работает автоматически — это встроенная функция пакета, которая выводит справку о доступных флагах.

**Как это работает**:
1. **При запуске программы** с флагом `-h` или `-help` пакет `flag` проверяет наличие этого флага.
2. **Выводится справка**, которая включает:
    - Имена всех зарегистрированных флагов
    - Их типы (`bool`, `string`, `int` и т.д.)
    - Значения по умолчанию
    - Описание (то, что вы передали последним аргументом в `flag.String()`, `flag.Int()` и т.д.)

3. **Программа завершается**, не выполняя основной код (если не переопределить поведение).

**Пример (на основе предыдущего кода)**

```bs
./main -h
```

Вывод будет примерно таким:

```bs
Usage of ./main:
  -fork
        булев флаг (default false)
  -num int
        число для вывода (default 42)
  -svar string
        строковая переменная (default "default")
  -word string
        слово для вывода (default "default")
```
**Как это реализовано внутри flag?**

Пакет `flag` автоматически регистрирует `-h` и `-help` при вызове `flag.Parse()`.

Если встречается один из этих флагов, вызывается `flag.Usage()` (по умолчанию выводит справку).

Программа завершается с кодом 2 (как ошибка, но не краш).

Можно ли кастомизировать справку?
Да! Можно переопределить `flag.Usage`:

```go
package main

import (
	"flag"
	"fmt"
	"os"
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Моя крутая программа v1.0\n\n")
		fmt.Fprintf(os.Stderr, "Использование: %s [опции] [аргументы...]\n\n", os.Args[0])
		flag.PrintDefaults() // стандартный вывод флагов
	}

	name := flag.String("name", "Гость", "Ваше имя")
	flag.Parse()

	fmt.Printf("Привет, %s!\n", *name)
}
```
Теперь при `-h` вывод будет таким:

```bs
Моя крутая программа v1.0

Использование: ./main [опции] [аргументы...]

  -name string
        Ваше имя (default "Гость")
```

**Интересные детали**:

- `-h` работает **только до вызова** `flag.Parse()` (если вызвать `flag.Parse()` вручную дважды, это может сломать поведение).
- Если передать неизвестный флаг (например, `-unknown`), `flag.Parse()` выведет справку и завершит программу.

В отличие от многих UNIX-утилит, `-h` в Go не требует явной регистрации — это встроенная фича.