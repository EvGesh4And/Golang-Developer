# Работа с вводом/выводом

## Цели вебинара

1. Использовать библиотеки ввода-вывода
2. Не пугаться, если библиотека просит какой то Reader вместо `string` или `[]byte`
3. Форматировать строки

## Смысл

1. Связать ваши решения с внешним миром
2. Свободно перемещать данные внутри программы и между ними

## Маршрут вебинара

- Введение в ввод-вывод в Go
- Стандартные интерфейсы: `Reader`, `Writer`, `Closer`
- Блочные устройства, Seeker
- Буферизация ввода/вывода
- Форматированный ввод и вывод: `fmt`
- Работа с командной строкой
- Рефлексия

## Библиотеки, пакеты

- `io` — базовые функции и интерфейсы
- `bufio` — буферизованный ввод/вывод
- `fmt` — форматированный ввод/вывод
- `os` (точнее `os.Open` и `os.File`) — открытие файла

Также, для работы с файловой системой будут полезны:
- `path` и `path/filepath` — для работы с путями к файлам

`ioutil` — устарел в 1.16 —> `io`, `os`

## Проблема унификафии

- Устройств ввода-вывода — много
- Хотим писать код, не зависящий от конкректного устройства

Путь: `Dependency Injection (DI)`


**Dependency Injection (DI)** — это паттерн проектирования, который позволяет управлять зависимостями между компонентами системы, передавая их извне вместо создания внутри.
- Преимущества DI
Снижение связности (Loose Coupling) – компоненты становятся независимыми друг от друга.
- Упрощение тестирования – можно легко заменять зависимости заглушками (mock).
- Гибкость – можно подменять зависимости без изменения кода клиента.
- Упрощение поддержки и расширяемости – код становится более модульным.


## Абстракция устройства ввода-вывода

Устройств ввода-вывода – много. У каждого свои особенности.

У каждого устройства есть свой пакет с <span style="color: red;">**имплементацией**</span> (реализацией):

*память, файл, сеть, пользователь + любые ваши*

Чтобы работать одинаково – go предоставляет <span style="color: green;">**интерфейсы**</span>;

Каждый <span style="color: green;">**интерфейс**</span> представляет одну "фичу" (возможность) устройства;
Каждая <span style="color: red;">**имплементация**</span> реализует набор фич.

![alt text](image.png)

## Пакет `io`

Содержит <span style="color: green;">**интерфейсы**</span> и инструменты для работы с ними.

Не привязан ни к каким <span style="color: red;">**имплементациям**</span> (таким как `ос`, файлы, сокеты и т.п.).

#### Из исходников Go
Пакет `io` предоставляет базовые интерфейсы для I/O-примитивов.
Его основная задача — **оборачивать** существующие реализации таких примитивов, например, из пакета `os`, в общие публичные интерфейсы, абстрагирующие функциональность, а также некоторые другие связанные примитивы.

Поскольку эти интерфейсы и примитивы оборачивают низкоуровневые операции с различными реализациями, если не указано иное, клиенты не должны предполагать, что они безопасны для параллельного выполнения.

### Обзор <span style="color: green;">**интерфейсов**</span>

**Основные**
|Чтение         |Запись         |Комментарий        |
|------         |------         |-----------        |
|`Reader `      |`Writer`       |массив байт        |
|`ByteReader`   |`ByteWriter`   |байты по 1         |
|`ReaderAt`     |`WriterAt`     |пропуски           |
|`ReaderFrom`   |`WriteTo`      |в другой интерфейс |
|`RuneReader`   |`StringWriter` |                   |
|`ByteScanner`  |               |                   |
|`RuneScaner`   |               |                   |

**Составные**
- `ReadCloser`
- `ReadSeekCloser`
- `ReadSeeker`
- `ReadWriteCloser`
- `ReadWriteSeeker`
- `ReadWriter`
- `WriteCloser`
- `WriteSeeker`

**Другое**
- `Closer`
- `Seeker`

### Как кто работает

```go
func main() {
    inFile, err := os.Open("filename.in"); check(err)
    outFile, err := os.Create("filename.io"); check(err)
    process(inFile, outFile)        // (1)

    inMem := bytes.NewReader([]byte("some content"))
    outMem := bytes.NewBuffer(nil)
    process(inMem, outMem)          // (2)

    process(os.Stdin, os.Stdout)    // (3)

    process(inFile, outMem)         // (4)
}
```

```go
func process(
    in io.Reader,
    out io.Writer,
) {
    data := make([]byte, 1024)

    _, err := in.Read(data)
    check(err)

    callLogic(data)

    _, err = out.Write(data)
    check(err)
}
```

### `io.Reader`

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

`io.Reader` — это нечто, **ИЗ** чего можно последовательно читать байты.

- Метод `Read` читает данные (из объекта) в буфер `p`, не более чем `len(p)` байт.
- Метод `Read` возвращает количество байт `n`, которые были прочитаны и записаны в `p`, причем `n` может быть меньше `len(p)`.
- Метод `Read` возвращает ошибку или `io.EOF` в случае конца файла, при этом он так же может вернуть `n > 0`, если часть данных были прочитаны до ошибки.

`io.EOF` - специальная ошибка, означаюшая что мы достигли конца потока (файла)

#### Из исходников Go
`Reader` — это интерфейс, который включает в себя базовый метод `Read`.

`Read` читает до `len(p)` байтов в `p`. Он возвращает количество прочитанных байтов `(0 <= n <= len(p))` и любую возникшую ошибку. Даже если `Read` возвращает `n < len(p)`, он может использовать весь `p` как рабочее пространство во время вызова.

Если доступны некоторые данные, но их меньше, чем `len(p)` байтов, `Read` обычно возвращает доступные данные вместо ожидания большего объема.

Если `Read` сталкивается с ошибкой или концом файла после успешного чтения `n > 0` байтов, он возвращает количество прочитанных байтов. Он может вернуть (ненулевую) ошибку в том же вызове или вернуть ошибку (и `n == 0`) при следующем вызове.

Один из примеров этого общего случая: `Reader`, возвращающий ненулевое количество байтов в конце входного потока, может вернуть либо `err == EOF`, либо `err == nil`. Следующий вызов Read должен вернуть `0, EOF`.

Вызывающие стороны всегда должны обрабатывать `n > 0` возвращенных байтов перед тем, как рассматривать ошибку `err`. Такой порядок действий правильно обрабатывает ошибки ввода-вывода, возникающие после чтения некоторых байтов, а также оба допустимых поведения `EOF`.

Если `len(p) == 0`, `Read` всегда должен возвращать `n == 0`. Он может вернуть
ненулевую ошибку, если известны какие-либо условия ошибки, например `EOF`. 

Реализациям `Read` не рекомендуется возвращать нулевое количество байтов с nil-ошибкой, за исключением случая, когда `len(p) == 0`. Вызывающие стороны должны интерпретировать возвращение `0` и `nil` как указание на отсутствие действий; в частности, это не означает `EOF`.

Реализации не должны сохранять ссылку на `p`.

### `io.Writer`

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

`io.Writer` — это нечто, ВО что можно последовательно записать байты.
- Метод `Write` записывает `len(p)` байт из `p` в объект (например файл или сокет).
- Метод `Write` реализует цикл до-записи внутри себя.
- Метод `Write` возвращает количество записанных байт `n` и ошибку, если `n < len(p)`

#### Из исходников Go

`Writer` — это интерфейс, который включает базовый метод `Write`.

`Write` записывает `len(p)` байт из `p` в нижележащий поток данных.

Он возвращает количество записанных байт из `p` `(0 <= n <= len(p))`
и любую ошибку, которая привела к досрочному завершению записи.

`Write` должен возвращать ненулевую ошибку, если `n < len(p)`.

`Write` не должен изменять данные в срезе, даже временно.
Реализации не должны сохранять `p`.


### `io.Closer`

```go
type Closer interface {
    Close() error
}
```

`io.Closer` — представляет ресурс, который следует вручную освободить после использования
- Если библиотека передала вам объект, поддерживающий `Closer`
    - значит библиотека ожидает что вы сами вызовете `Close`;
- Если вы передаёте свой объект в функцию, принимающую `Closer`
    - ожидайте что его там закроют;
- `Close` следует вызывать как можно раньше;
- `Close` часто вызывают в блоке `defer f.Close()` (забывая при этом обработать ощибку);
- Забытый `Close` - причина утечки ресурсов (например, навечно открытый файл)

Остальные интерфейсы пакета `io` рассмотрим позже

#### Из исходников Go

`Closer` — это интерфейс, который включает базовый метод `Close`.

Поведение `Close` после первого вызова не определено.
Конкретные реализации могут документировать свое поведение.

## Работа с файлами (... и последовательный доступ)

### Открываем файлы (общий случай)

Для открытия файла на чтение используем `os.OpenFile`

```go
var file *os.File // файловый дескриптор в Go
file, err := os.OpenFile(path, os.O_RDWR, 0644)
if err != nil {
    if os.IsNotExist(err) {
        // файл не найден ...
    }
    // другие ошибки, например нет прав ...
}
defer file.Close()
```

#### Из исходников Go

`OpenFile` — это обобщённый вызов открытия файла;
большинство пользователей предпочтут использовать `Open` или `Create`.

Он открывает указанный файл с заданным флагом (например, `O_RDONLY` и т. д.).

Если файл не существует и передан флаг `O_CREATE`, он создаётся с правами доступа `perm` (до применения umask).

В случае успешного выполнения методы возвращённого объекта `File` могут использоваться для ввода-вывода.

В случае ошибки она будет представлена типом `*PathError`.


### Специальные "сокращения"

#### Open

```go
os.Open(name) = OpenFile(name, os.O_RDONLY, 0)
```

#### Из исходников Go
`Open` открывает указанный файл для чтения. 
В случае успешного выполнения методы возвращённого файла могут использоваться для чтения; связанный файловый дескриптор имеет режим `O_RDONLY`.

В случае ошибки она будет представлена типом `*PathError`.

#### Create
```go
os.Create(name) = OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
```

#### Из исходников Go

`Create` создаёт или обрезает указанный файл. 
Если файл уже существует, его содержимое **обнуляется**. 
Если файл не существует, он создаётся с правами `0o666` (до применения umask).
В случае успешного выполнения методы возвращённого объекта `File` могут использоваться для ввода-вывода; связанный файловый дескриптор имеет режим `O_RDWR`.
В случае ошибки она будет представлена типом `*PathError`.

### Интерфейсы os.File

```go
Reader
ReaderAt
ReaderFrom

Writer
WriterAt
StringWriter

Seeker
Closer (!)
```


### Чтение файла

Читаем первые `N` байт в `buf`, используя `io.Reader`

```go
 N := 1024 // мы заранее знаем сколько хотим прочитать
 buf := make([]byte, N) // подготавливаем буфер нужного размера
 file, _ := os.Open(path) // открываем файл (не забыть про err!)
 offset := 0
 for offset < N {
    read, err := file.Read(buf[offset:])
    offset += read
    if err == io.EOF {
        // что если не дочитали ?
        break
    }
    if err != nil {
        log.Panicf("failed to read: %v", err)
    }
 }
```

#### Удобства для чтения

Гарантированно заполнить буфер
```go
b := make([]byte, 1024*1024)
file, _ := os.Open(path)
read, err := io.ReadFull(file, b) // содержит цикл внутри
```
Прочитать все до конца файла
```go
file, _ := os.Open(path)
b, err := io.ReadAll(file) // err настоящая ошибка, не EOF
```

Или еще короче (для скриптов)
```go
b, err := os.ReadFile(path) // прочитать весь файл по имени
```
операции в пакете `io` применимы к любым `io.Reader`, а не только файлам

### Пишем в файлы

Пишем содержимое `b` в файл используя `io.Writer`

```go
b := make([]byte, 1024*1024) // заполнен нулями
file, _ := os.Create(path)
written, err := file.Write(b)

if err != nil {
    log.Panicf("failed to write: %v", err)
}
// мы записали 1M данных !
file.Close() // чтобы очистить буферы ОС
```
В отличие от операции чтения, тут цикл не нужен.

#### Удобства для записи

Целиком переписать файл:

```go
b := make([]byte, 1024*1024)
err := os.WriteFile(path, b, 0644)
```

