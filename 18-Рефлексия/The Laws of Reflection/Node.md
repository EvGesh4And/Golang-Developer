# Законы рефлексии

Роб Пайк
6 сентября 2011 года

## Введение

**Рефлексия в программировании** — это способность программы изучать собственную структуру, в частности с помощью типов; это форма метапрограммирования. При этом она часто становится источником путаницы.

В этой статье мы попытаемся внести ясность, объяснив, как работает рефлексия в Go. Модель рефлексии в каждом языке своя (а многие языки вообще её не поддерживают), но эта статья посвящена Go, поэтому в оставшейся части статьи слово «рефлексия» следует понимать как «рефлексия в Go».

Примечание, добавленное в январе 2022 года: эта статья в блоге была написана в 2011 году и предшествует появлению параметрического полиморфизма (также известного как дженерики) в Go. Несмотря на то что ключевые идеи статьи остаются актуальными, в некоторых местах текст был скорректирован, чтобы не вводить в заблуждение тех, кто знаком с современными возможностями Go.

## Типы и интерфейсы

Поскольку рефлексия опирается на систему типов, начнём с краткого напоминания о типах в Go.

Go — это язык со статической типизацией. **Каждая переменная имеет статический тип**, то есть ровно один тип, известный и зафиксированный во время компиляции, например: `int`, `float32`, `*MyType`, `[]byte` и так далее. Если, например, объявить:

```go
type MyInt int

var i int
var j MyInt
```

то переменная `i` будет иметь тип `int`, а j — тип `MyInt`. Несмотря на то, что **базовые типы переменных могут совпадать**, они **представляют собой разные типы**, поэтому присваивать значения напрямую между ними нельзя — потребуется явное преобразование типов.

Одной из ключевых категорий типов являются **интерфейсные типы**, которые представляют собой фиксированные наборы методов. (При обсуждении рефлексии можно не углубляться в использование интерфейсов как ограничений в полиморфном коде). **Переменная интерфейса может содержать любое конкретное** (то есть не интерфейсное) **значение**, **если его тип реализует необходимые методы**. Яркими примерами являются `io.Reader` и `io.Writer` из стандартного пакета [`io`](https://pkg.go.dev/io):

```go
// Reader — интерфейс, содержащий основной метод Read.
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer — интерфейс, содержащий основной метод Write.
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

**Любой тип, реализующий метод `Read` (или `Write`) с указанной сигнатурой**, автоматически считается **реализующим интерфейс `io.Reader` (или `io.Writer`)**. Это означает, что переменная типа `io.Reader` может принимать любое значение, чей тип имеет метод `Read`:

```go
var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// и так далее
```

Важно отметить, что независимо от того, какое конкретное значение хранится в переменной `r`, её статический тип остаётся `io.Reader`: Go — язык с жёсткой статической типизацией, и тип переменной определяется на этапе компиляции.

Чрезвычайно важный пример интерфейсного типа — это пустой интерфейс:

```go
interface{}
```

или его эквивалентный псевдоним:

```go
any
```

Он представляет собой пустое множество методов и, соответственно, удовлетворяется любым значением, поскольку каждое значение в Go имеет ноль или более методов.

Некоторые говорят, что интерфейсы в Go являются **динамически типизированными**, но это вводит в заблуждение. На самом деле они **статически типизированы**: переменная интерфейсного типа **всегда имеет один и тот же статический тип**, и хотя во время выполнения тип значения, хранящегося в этой переменной, может изменяться, само значение всегда будет удовлетворять интерфейсу.

Нам **нужно быть точными во всём этом**, потому что отражение и интерфейсы тесно связаны.

## Представление интерфейса

Русс Кокс написал [подробную статью](https://research.swtch.com/interfaces) о внутреннем устройстве интерфейсных значений в Go. Здесь нет нужды пересказывать её целиком, но стоит привести краткое упрощённое изложение.

Переменная интерфейсного типа в Go хранит пару: **конкретное значение**, присвоенное переменной, и **дескриптор** типа этого значения. Точнее говоря, **значение — это конкретный объект**, реализующий интерфейс, а **дескриптор типа** — это полное описание его типа. Например, после следующего кода:

```go
var r io.Reader
tty, err := os.OpenFile("/dev/tty", os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
```

переменная `r` содержит, схематично,  пару (значение, тип): (`tty`, `*os.File`). Обратите внимание: тип `*os.File` реализует не только метод `Read`. Хотя через интерфейс `io.Reader` доступен только `Read`, конкретное значение внутри интерфейсной переменной хранит всю информацию о своём типе. Именно поэтому мы можем написать следующее:

```go
var w io.Writer
w = r.(io.Writer)
```

Выражение в этом присваивании — это утверждение о типе (`type assertion`): оно утверждает, что значение внутри `r` также реализует `io.Writer`, и значит, его можно присвоить переменной `w`. После присваивания переменная `w` будет содержать ту же пару (`tty`, `*os.File`), что и `r`. Статический тип интерфейса определяет, какие методы можно вызвать у переменной, даже если конкретное значение внутри реализует больше методов.

Продолжая, мы можем сделать это:
```go
var empty interface{}
empty = w
```

Теперь переменная `empty`, имеющая тип пустого интерфейса, снова будет содержать ту же пару (`tty`, `*os.File`). Это удобно: пустой интерфейс может хранить любое значение и при этом содержит всю информацию о нём, которая нам может понадобиться.

(Здесь нам не нужна явная проверка типа, потому что статически известно, что `w` удовлетворяет пустому интерфейсу. В случае с переходом от `Reader` к `Writer` нам нужно было явно указать приведение типа, поскольку методы `Writer` — не подмножество методов `Reader`.)

Важно помнить, что пара, хранящаяся внутри интерфейсной переменной, всегда имеет вид **(значение, конкретный тип)** и никогда — (значение, интерфейсный тип). **Интерфейсы не содержат интерфейсных значений.**.

Теперь мы готовы к рефлексии.

## Первый закон рефлексии
## 1. Рефлексия начинается с интерфейсного значения и приводит к объекту рефлексии.

На базовом уровне рефлексия (reflection) — это **просто механизм, позволяющий исследовать пару «тип и значение», хранящуюся внутри переменной интерфейсного типа**.

Для начала нам нужно знать о двух типах из пакета `reflect`: `Type` и `Value`. Эти два типа предоставляют доступ к содержимому интерфейсной переменной. Две простые функции `reflect.TypeOf` и `reflect.ValueOf` — позволяют извлечь из значения интерфейсного типа соответственно объекты `reflect.Type` и `reflect.Value`.

(Также, из объекта `reflect.Value` легко получить связанный с ним `reflect.Type`, но пока будем держать понятия `Value` и `Type` отдельно)

Начнём с `TypeOf`:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x))
}
```

Эта программа выведет:
```
type: float64
```

Может показаться, что здесь никакого интерфейса нет — ведь мы передаём переменную типа `float64`, а не интерфейсное значение.
Но он есть: как сообщает [документация (godoc)](https://pkg.go.dev/reflect#TypeOf), сигнатура `reflect.TypeOf` использует пустой интерфейс:

```go
// TypeOf возвращает объект отражения типа (reflect.Type) для значения,
// переданного через interface{}.
func TypeOf(i interface{}) Type
```

Когда мы вызываем `reflect.TypeOf(x)`, значение `x` сначала неявно упаковывается в значение пустого интерфейса (`interface{}`), а уже затем передаётся функции. Внутри `reflect.TypeOf` это значение распаковывается, и извлекается информация о типе.

Аналогично, функция `reflect.ValueOf` извлекает значение:

```go
var x float64 = 3.4
fmt.Println("value:", reflect.ValueOf(x).String())
```

Результат:
```
value: <float64 Value>
```

(Здесь мы явно вызываем метод `String`, потому что `fmt.Println` по умолчанию проникает внутрь объекта `reflect.Value` и отображает само хранимое значение. Метод `String` этого не делает.)

И `reflect.Type`, и `reflect.Value` предоставляют множество методов для анализа и работы с ними.
Например, у `Value` есть метод `Type()`, который возвращает `Type` из `reflect.Value`. `Type` и `Value` — имеют метод `Kind()`, который возвращает константу, указывающую, какой тип элемента хранится:: `Uint`, `Float64`, `Slice` и т.д.
Кроме того, у `Value` есть методы `Int` и `Float`, которые позволяют получить численные значения (соответственно, в виде `int64` и `float64`):


```go
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())
fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
fmt.Println("value:", v.Float())
```

Вывод:
```
type: float64
kind is float64: true
value: 3.4
```

Существуют и методы вроде `SetInt` и `SetFloat`, но для их использования нужно понимать, что такое изменяемость (**settability**) — об этом пойдёт речь в третьем законе рефлексии.

Библиотека рефлексии обладает парой свойств, на которые стоит обратить внимание. Во-первых, для упрощения API "getter" и "setter" в `Value` работают с максимально широкими типами.
Например, метод `Int` возвращает `int64`, а `SetInt` принимает `int64`, даже если конкретное значение было типа `int8`, `int32` или `uint8`.
Поэтому может потребоваться явное преобразование:
```go
var x uint8 = 'x'
v := reflect.ValueOf(x)
fmt.Println("type:", v.Type())                            // uint8
fmt.Println("kind is uint8:", v.Kind() == reflect.Uint8)  // true
x = uint8(v.Uint())                                       // v.Uint() возвращает uint64
```

Второе свойство заключается в том, что метод `Kind()` отражает базовый (встроенный) тип значения, а не его статический тип.
Если мы используем пользовательский тип на основе `int`, например:

```go
type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
```

то `v.Kind()` вернёт `reflect.Int`, хотя статический тип переменной — `MyInt`, а не `int`.

То есть `Kind` не различает `int` и `MyInt`, в то время как `Type` — различает.


## Второй закон рефлексии
## 2. Рефлексия идёт от объекта отражения обратно к интерфейсному значению.

Подобно физической рефлексии, отражение в Go обладает обратимостью.

Имея объект `reflect.Value`, мы можем восстановить исходное интерфейсное значение с помощью метода `Interface`. Фактически, этот метод заново упаковывает тип и значение во внутреннюю форму интерфейса и возвращает результат:

```go
// Interface возвращает значение v как interface{}.
func (v Value) Interface() interface{}
```

Как следствие, мы можем сказать
```go
y := v.Interface().(float64) // y будет иметь тип float64
fmt.Println(y)
```
чтобы напечатать значение типа `float64`, представленное объектом отражения `v`.

Можно сделать даже лучше.
Все аргументы функций `fmt.Println`, `fmt.Printf` и т.д. передаются как значения пустого интерфейса (`interface{}`), которые внутри пакета `fmt` распаковываются точно так же, как мы делали это в предыдущих примерах.

Следовательно, чтобы корректно распечатать содержимое `reflect.Value`, достаточно передать результат вызова `Interface()`:

```go
fmt.Println(v.Interface())
```

(После того как была написана первая версия этой статьи, в пакет `fmt` внесли изменения: теперь он сам распаковывает объекты типа `reflect.Value`. Поэтому можно просто написать:
```go
fmt.Println(v)
```
и получить тот же результат. Но для ясности мы по-прежнему будем использовать `.Interface()`)

Так как наше значение — `float64`, мы можем даже задать формат вывода с плавающей точкой:
```go
fmt.Printf("value is %7.1e\n", v.Interface())
```
и получим, например:
```
3.4e+00
```

Обратите внимание: не нужно делать приведение типа через `type assertion` (`.(float64)`), чтобы корректно отформатировать значение.
Значение пустого интерфейса уже содержит всю информацию о конкретном типе, и `Printf` сам её извлечёт.

Подведём итог:
Метод `Interface` — это обратная операция к функции `ValueOf`, за тем исключением, что результат всегда имеет статический тип `interface{}`.

Ещё раз:

**Рефлексия позволяет переходить от интерфейсных значений к объектам отражения — и обратно**.

## Третий закон рефлексии
## 3. Чтобы изменить объект отражения, значение должно быть устанавливаемым (settable).

Этот закон — самый тонкий и запутанный, но его довольно легко понять, если исходить из основных принципов.

Рассмотрим пример кода, который не работает, но полезен для анализа:

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Ошибка: паника
```

Если запустить этот код, он завершится паникой с загадочным сообщением:
```
panic: reflect.Value.SetFloat using unaddressable value
```

Проблема не в том, что значение 7.1 не имеет адреса. Проблема в том, что `v` не является **устанавливаемым** (не `settable`).
Устанавливаемость — это свойство объекта `reflect.Value`, и не каждый объект `Value` обладает этим свойством.

Метод `CanSet()` сообщает, можно ли установить значение:

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
fmt.Println("settability of v:", v.CanSet())
```

Выведет:

```
settability of v: false
```

Вызывать метод `Set` на объекте, который не является устанавливаемым, — ошибка.

Но что такое **«устанавливаемость» (settability)**?

Это похоже на **«адресуемость» (addressability)**, но ещё строже.
Речь идёт о том, может ли объект отражения изменить реальную область памяти, из которой он был создан. Это возможно только в том случае, если объект отражения действительно «держит» оригинальный элемент, а не его копию.

Когда мы пишем:
```go
var x float64 = 3.4
v := reflect.ValueOf(x)
```
Мы передаём копию `x` в `reflect.ValueOf`. Интерфейсное значение, переданное в `reflect.ValueOf`, содержит копию `x`, а не сам `x`.

Если бы была разрешена операция:
```go
v.SetFloat(7.1)
```
она бы изменила не сам `x`, а только копию внутри `v`, что было бы бессмысленно и вводило бы в заблуждение. Это было бы запутанно и бесполезно, поэтому это незаконно, а свойство `settability` используется для решения этой проблемы.

Это может показаться странным, но на самом деле — привычная ситуация. Вспомните передачу значения в функцию:
```go
f(x)
```
Мы не ожидаем, что `f` сможет изменить `x` из-за того, что мы передали копию значения `x`, а не сам `x`. Если мы хотим, чтобы `f` изменил `x` напрямую, мы должны передать нашей функции адрес `x` (то есть указатель на `x`):

```go
f(&x)
```

То же самое и с рефлексией: eсли мы хотим изменить `x` с помощью отражения, мы должны передать библиотеке отражения указатель на значение, которое хотим изменить.

Давайте сделаем это. Сначала мы инициализируем `x` как обычно, а затем создадим значение отражения, которое указывает на него, под названием `p`.

```go
var x float64 = 3.4
p := reflect.ValueOf(&x) // важно: &x — передаём указатель
fmt.Println("type of p:", p.Type())
fmt.Println("settability of p:", p.CanSet())
```

Результат:

```go
type of p: *float64
settability of p: false
```
Объект `p` — не устанавливаемый, потому что это указатель.
Но мы не хотим изменить `p`, мы хотим изменить то, на что он указывает — т.е. (по сути) `*p`.

Чтобы получить то, на что `p` указывает, мы вызываем метод `Elem` объекта `Value`, который косвенным образом обращается к указателю, и сохраняем результат в отражении `Value` под названием `v`:
```go
v := p.Elem()
fmt.Println("settability of v:", v.CanSet())
```
Теперь `v` — устанавливаемый объект:

```go
settability of v: true
```

И поскольку `v` представляет `x`, мы можем изменить значение:

```go
v.SetFloat(7.1)
fmt.Println(v.Interface())
fmt.Println(x)
```

Вывод:

```
7.1
7.1
```

Вывод:
Рефлексия может показаться сложной, но она делает то же самое, что и обычный Go-код, просто через абстракции `reflect.Type` и `reflect.Value`.

Важно помнить:
Чтобы изменить значение через отражение, нужно передать указатель — то есть объект должен быть устанавливаемым.

## Работа со структурами через reflection

В предыдущем примере переменная `v` не была указателем сама по себе, но была получена из указателя. Подобная ситуация часто возникает, когда вы хотите изменять поля структуры через отражение. Всё, что нам нужно — это адрес структуры, тогда мы можем изменять её поля.

Вот простой пример, который анализирует значение структуры `t`.
Мы создаём объект отражения, передав адрес структуры `&t`, потому что далее хотим изменять её поля.

Обрати внимание:
Мы получаем имена полей из типа `typeOfT`, а значения полей — это обычные `reflect.Value`.

```go
type T struct {
    A int
    B string
}

t := T{23, "skidoo"}
s := reflect.ValueOf(&t).Elem()
typeOfT := s.Type()

for i := 0; i < s.NumField(); i++ {
    f := s.Field(i)
    fmt.Printf("%d: %s %s = %v\n", i,
        typeOfT.Field(i).Name, f.Type(), f.Interface())
}
```

Вывод:
```
0: A int = 23
1: B string = skidoo
```

Важный момент: только экспортируемые поля (с заглавной буквы) можно изменять через reflection.

Поскольку `s` — это устанавливаемый (settable) объект, мы можем изменить поля структуры:
```go
s.Field(0).SetInt(77)
s.Field(1).SetString("Sunset Strip")
fmt.Println("t is now", t)
```

Результат:
```
t is now {77 Sunset Strip}
```

Если бы мы вместо `&t` передали просто `t`, то `s` был бы неустанавливаемым, и попытка изменить поля через `SetInt` и `SetString` вызвала бы панику.

## Заключение

Три закона рефлексии в Go:

- Reflection идёт от `interface{}` к `reflect.Value`. Сначала вы преобразуете переменную в отражение с помощью `reflect.ValueOf`.

- Reflection идёт от `reflect.Value` обратно к `interface{}`. С помощью `.Interface()` вы получаете исходное значение из `reflect.Value`.

- Чтобы изменить значение через отражение, оно должно быть устанавливаемым (settable). Это значит: вы должны передать указатель и обращаться к значению через `.Elem()`.

Теперь, понимая эти три закона, пользоваться рефлексией в Go становится намного проще, хотя она остаётся тонким инструментом. Это мощный механизм, который следует использовать только при необходимости, так как он сложнее, чем обычный код, и более подвержен ошибкам.

В отражении есть много других аспектов, которые мы не рассмотрели: отправка и получение данных по каналам, выделение памяти, использование срезов и карт, вызов методов и функций, — но этот пост и так достаточно длинный. Некоторые из этих тем мы рассмотрим в следующей статье.