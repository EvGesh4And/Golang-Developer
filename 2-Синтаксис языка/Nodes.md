# Синтаксис языка Go

## Преподаватель  
**Рубаха Юрий**  

## Содержание занятия  
- Общая информация о синтаксисе  
- Переменные  
- Функции  
- Управляющие конструкции  

---

## Общая информация о синтаксисе  

Основные элементы синтаксиса Go:  
- `package` — определяет пакет  
- `import` — подключает пакеты  
- `func main()` — точка входа в программу  
- Комментарии: `//` (однострочные), `/* */` (многострочные)  
- Блоки кода: `{ }`  

**Дополнительно:**  
- **Невидимые точки с запятой** (автоматическая расстановка `;` компилятором)  
- **Управление видимостью** (заглавная буква в имени делает объект экспортируемым)  

---

### **1. package**  

Каждый `.go`-файл должен содержать ровно **один** оператор `package`.  

```go
package main
```

- Пакеты могут иметь разные имена, но в исполняемом приложении **должен быть пакет `main`**, содержащий точку входа.

---

### **2. func main() { }**  

Функция `main()` является точкой входа в программу.  

```go
package main

import "fmt"

func main() {
    fmt.Println("Hello, Go!")
}
```

- Должна находиться в пакете **main**  
- Запускается автоматически рантаймом при старте программы  
- Не принимает аргументы и не возвращает значения  

> **Важно**: В других пакетах можно объявлять `main()`, но она будет обычной функцией и **не будет** вызываться автоматически.  

---

### **3. import**  

Для использования пакета его нужно импортировать.  

```go
import "fmt"
```

Перед `import` **не должно быть** ничего, кроме `package`.  

Форматы импорта:  

1. **Обычный импорт:**  
    ```go
    import "fmt"
    ```

2. **Групповой импорт:**  
    ```go
    import (
        "fmt"
        "sync"
    )
    ```

3. **Именованный импорт:**  
    ```go
    import (
        f "fmt"
        m "math"
    )
    ```

4. **Пустой импорт (для инициализации пакета):**  
    ```go
    import _ "some/package"
    ```

---

### **4. Комментарии //, /\* \*/**  

В Go есть три типа комментариев:  

1. **Однострочные (`//`)**  
    ```go
    // Это однострочный комментарий
    fmt.Println("Hello, World!")
    ```

2. **Многострочные (`/* */`)**  
    ```go
    /*
    Это блочный комментарий,
    который может занимать несколько строк.
    */
    fmt.Println("Hello, World!")
    ```

3. **Директивы (например, `//nolint`)**  
    
    Некоторые комментарии используются инструментами для управления анализаторами кода.  
    
    ```go
    //nolint:golint
    func main() {
        fmt.Println("Hello, World!")
    }
    ```
    
    **Примеры директив:**  
    - `//go:generate` — директива для генерации кода  
    - `//go:build` — директива для управления сборкой  
    
    **Пример `//go:generate`:**  
    ```go
    //go:generate go run gen.go
    ```

### **5. Блоки `{ }`** 

Почти весь код в Go находится внутри блоков, заключённых в фигурные скобки `{ }`.  
Блоки могут содержать объявления переменных и типов, выполнение выражений, вызовы функций.  

Блоки могут быть вложенными: переменные, объявленные во внешних блоках, доступны во внутренних. Однако переменные, объявленные во внутренних блоках, не видны снаружи.  

Блоки используются в функциях, управляющих конструкциях (`if`, `for`, `switch`), а также в анонимных кодовых блоках.

## Переменные

- простейшие типы данных
- способы объявления переменных
- присвоение значений переменным
- множественные присвоения
- символ нижнего подчеркивания **_**
- zero-values
- константы, iota

---

### **1. Простейшие типы данных**

Go – строготипизированный язык. У каждой переменной есть конкретный тип. Он определяется при создании переменной и не меняется в ходе выполнения программы.

Тип переменной указывает компилятору на:
- Сколько переменная занимает памяти
- Из чего она состоит
- Что с ней можно делать

Далее будент рассмотрено три типа данных
- **int** – хранит целые числа со знаком
- **bool** – хранит логическое значение (`true` / `false`) 
- **string** – хранит строку символов.

---

### **2. Способы объявления переменных**

Можно выделить **6** способов объявления переменных.

1. С помощью ключевого слова **var, С указанием типа и БЕЗ указания значения**

    ```go
    var temperature int
    var message string
    ```

2. С помощью ключевого слова **var, С указанием типа и указанием значения**

    ```go
    var temperature int = -5
    var message string = "Холодно"
    ```
    Во втором случае тип данных иногда можно не указывать, если тип переменной совпадает с типом значения.

> **Выведение типов** – Go определяет тип выражения справа, и наделяет переменную слева этим же типом.

3. С помощью ключевого слова **var, БЕЗ указания типа и С указанием значения**
    
    ```go
    var temperature = -5    //будет выведен тип int
    var message = "Холодно" //будет выведен тип string
    var ok = true           //будет выведен тип boo
    ```

4. Без ключевого слова **var, БЕЗ указания типа и С указанием значения**. Очень характерный для Go
    
    ```go
    var temperature = -5    //будет выведен тип int
    var message = "Холодно" //будет выведен тип string
    var ok = true           //будет выведен тип boo
    ```
    
    В этом случае переменная **и объявляется, и получает начальное значение**. Тип переменной будет жестко зависеть от типа значения, которое было в момент задания переменной.

### Области определения переменных

1. Переменные могут быть объявлены за пределами блоков `{ }`. Тогда это будут ***глобальные переменные*** уровня пакета. Такие переменные можно объявлять только способами **1-3** с помощью слова **var**.

2. Переменные внутри блоков называются **локальными**. Их можно объявлять всеми **4** способами.

    ```go
    package main

    var price int
    var name string = "Автомобиль"
    var age = 10
    // здесь так нельзя
    // power:=200

    func main() {
        var price int
        var name string = "Грузовик"
        var age = 5
        // здесь так можно
        power := 500
    }
    ```
> Одноименные локальные переменные **«затеняют»** глобальные.

---

### **3. Присвоение значений переменным**

Переменной можно присвоить значение
- литерала («захардкоженого значения»),
- другой переменной,
- выражения,
- результат вызова функции.

```go
package main

func main() {
    var a = 10          //присвоено значение литерала
    b := a              //присвоено значение другой переменной
    var c int = a + b   //присвоено значение выражения

    //и дальше делаем всё, что нам нужно для задачи
    c = 5
    b = 2*a + b
    //и т.д. Полная свобода действий
}
```

---

### **4. Множественные присвоения**

Оператор присвоения **=** в Go позволяет присваивать несколько значений нескольким переменным. **Количество значений слева должно совпадать с количеством значений справа**. Переменные могут быть разных типов. Но типы переменных нарушать нельзя.

```go
package main

func main() {
    //объявление с множественным присвоением
    var a, b = 10, 20
    //множественное присвоение с выведением типа
    age, name := 20, "Вася"
    //обмен значениями
    a, b = b, a
}
```

> **Для ясности**: сначала вычисляются все значения в правой части, а потом записываются в переменные левой части.

---

### **5. Символ нижнего подчеркивания _**

**Все переменные, объявленные в блоках `{ }` обязательно должны быть использованы для чтения**! Если этого не сделать, будет ошибка компиляции. К переменным уровня пакета такого требования нет.

**_** - это универсальный приемник значений любых типов. В него можно записать любое значение.

Применяется для:
1) Временно, чтобы компилятор увидел, что переменная используется.
2) Для выравнивания количества принимаемых и передаваемых значений (увидим позже).

```go
package main

func main() {
    var a = 10  //пока что a не используется для чтения
    _ = a       //теперь используется
}
```

> Этим злоупотреблять не стоит! Но есть и другие применения _, которыми можно пользоваться сколько угодно.

---

### **6. zero-values**

В Go все объявленные переменные (независимо от способа) являются инициализированными и могут сразу же использоваться как на чтение, так и на запись.
Даже если переменной не присвоено значение, она содержит не «мусор» – непредсказуемое значение, а zero-value. Эти значения разные для разных типов данных.

```go
var a int       //будет равно 0
var b string    //будет равно "" (пустая строка)
var c bool      //будет равно false
```

---

### **7. Константы**

- В Go есть константы – переменные, значения которых нельзя менять в процессе выполнения программы.
- Константы определяются с помощью слова **const**.
- Константы могут быть уровня пакета и блока `{ }`, как и переменные.
- Не все типы данных пригодны для создания констант (об этом в след. лекциях).

```go
const absoluteZero = -273
const myName = "Юра"

func main() {
    const temperature = 451
    const hello = "Hello world!"
}
```

---

### **8. iota**

**iota** – особое ключевое слово, которое позволяет создать несколько констант со связанными друг с другом значениями. Iota **начинается с 0** и **для каждой следующей константы увеличивается на 1**.

Можно сказать, что **iota** — это индекс строки внутри блока `const (...)`, но с некоторыми нюансами:

- Начинается с `0` и увеличивается на `1` в каждой новой строке внутри `const (...)`.
- Сбрасывается в каждом новом блоке const.
- Не зависит от значений переменных, только от их положения.
- Если строка не использует `iota`, это не влияет на его значение — он продолжает увеличиваться.

```go
const (
    zero = iota     //будет иметь значение 0
    one = iota      //будет иметь значение 1
    two             //iota опустили, но она продолжает работать, 2
    three           //3
    _               //задействуем пустой получатель, чтобы пропустить 4
    five            //5
)
```

Iota можно использовать и в составе более сложных выражений

```go
const (
    one = iota +1   //задали выражение, результат =1
    two             //выражение будет повторяться, результат =2
    three           //повторяется, результат 3
)
const (
    ten =(iota+1)*10    //10
    twenty              //20
    thirty              //30
)
```

---

## Функции

- Именованные функции
- Принимаемые и возвращаемые значения
- Сигнатура функции
- `return` для разных случаев
- Вызов функции
- Присвоение переменным результата вызова функции
- Обычный набор возвращаемых значений `(res, err)` или `(res, ok)`


### **1. Именованые функции**

Объявление именованной функции состоит из
- ключевого слова `func` (**обязательно**)
- имени функции (**обязательно**)
- перечня входных параметров (опционально)
- перечня возвращаемых значений (опционально)
- тела функции (**обязательно**)

```go
func sum (a int, b int) int {
    return a+b
}
```

Имена функций в пакете должны быть уникальными. Перегрузок функций в Go нет. Мы не можем сделать две функции с одинаковым именем даже с разными параметрами.

### **2. Принимаемые и возвращаемые значения**

В Go нет «процедур». Вместо процедур используются функции без возвращаемых значений.

Если функция принимает подряд несколько параметров одного типа, описание можно сократить так:
```go
func sum(a, b int) int {

}
```

То же самое, что и:
```go
func sum(a int, b int) int {

}
```

Функции могут возвращать более, чем одно значение. Это выглядит так:
```go
func div(a, b int) (int, int) {
    
}
```

Выше пример функции с именоваными входными параметрами, и неименованными выходными параметрами.

А это пример функции с именованными входными и выходными параметрами:
```go
func div(a, b int) (d int, r int) {

}
```

5-й и 6-й способ объявления переменных – это их объявление в качестве входного или выходного параметра функции. **Если параметр функции именован, то на уровне функции он уже существует как переменная**, и может быть использован как для чтения так и для записи, как 
```go
func div(a, b int) (d int, r int) {
    d = a/b
    r = a%b
}
```

Как видим, переменные `a, b, d, r` используются уже без дополнительных объявлений

### **3. Сигнатура функции**

**Сигнатура функции** – набор типов входных и выходных параметров функции, учитывая их порядок. При этом имя функции, имена параметров и вообще их именованность, а так же тела (реализации) функций значения не имеют.

Ниже пример двух функций с одинаковой сигнатурой

```go
func getWeekDayName(day int) string {
// ... реализация опущена
}
func getMonthName (monthNumber int) (monthName string) {
//... реализация опущена
}
```

### **4. Ключевое слово `return`**

`return` – это команда, выполнение которой завершает выполнение функции. `return` – это именно **команда**, а не «отметка» конца функции, поэтому
- `return` может в функции быть не один
- `return`’ов может быть в функции несколько
- `return` завершает выполнение функции безусловно

>Если функция не имеет выходных параметров, она может не содержать `return`. Такая функция будет завершаться при достижении последней строки функции.

>Для функций с возвращаемыми параметрами наличие хотя бы одного `return` в теле обязательно.

Пример функции без `return`

```go
func hello(message string) {
    fmt.Println("Сейчас выведем сообщение")
    fmt.Println(message)
} //функция закончится здесь
```

Но и для таких функций можно в теле использовать слово `return`, чтобы прекратить выполнение функции в определенном месте.

Функции, возвращающие параметры, должны содержать `return`. При этом все сценарии выполнения функции должны заканчиваться `return`.
А возвращаемые в `return` значения должны совпадать по типам с возвращаемыми параметрами функции.

> При этом если указан именованный возвращаемый параметр `(a int)`, то необязательно возвращать его – можно `return b` (если указать просто `return`, то это эквивалентно `return a`)

Возвращать можно литералы, значения переменных, или значения выражений
```go
// функция возвращает день и месяц Нового года
func newYear() (int, string) {
    return 1, "январь"
}
```
Еще пример
```go
// возвращает день, месяц и год Миллениума
func millenium() (int, string, int) {
    thousand := 1000
    first := 1
    jan := "январь"
    return first, jan, 2 * thousand
} // функция вернет 1, "январь", 2000
```

Если у функции выходные параметры (возвращаемые параметры) именованы, то они уже создаются в момент вызова функции.
В этом случае мы можем делать `return` без параметров, тогда из функции вернутся параметры с теми значениями, которые были на момент `return`, или `return` с параметрами.
```go
func millenium() (day int, month string, year int) {
    day=1
    month="Январь"
    year=1000*2
    return
} // функция вернет 1, "январь", 2000
```

### **5. Вызов функции**

Для вызова функции мы указываем её имя и в круглых скобках перечисляем передаваемые в функцию значения. Если передаваемых значений нет, оставляем скобки пустыми.
Передаваемые значения должны соответствовать типам в сигнатуре функции.

В функцию **ВСЕГДА** передаются копии тех значений, что мы передали при вызове. Поэтому в большинстве случаев из функции нельзя изменить те переменные, которые в неё переданы (если это не указатели, срезы, карты).

```go
package main

import "fmt"

func main() {
    value := 10
    change(value)       //вызов функции
    fmt.Println(value)  //value по-прежнему равняется 10
}

func change(a int){
    a = a + 1
}
```

### **5. Результат вызова функции**

Если у функции есть возвращаемое значение, то результат вызова функции можно сохранить в переменную или переменные.

Например функцию **div** можно вызвать несколькими способами

```go
func div(a, b int) (int, int) {
    return a/b, a%b
}

func main() {
    div(100, 3)             //игнорируем результат
    d, r := div(100, 3)     //сохраняем оба результата
    _, r := div(100, 3)     //сохраняем только второй параметр
    d, _ := div(100, 3)     //сохраняем только первый параметр
    _, _ = div(100, 3)      //ничего не сохраняем. Заметьте – без :
}
```

Результаты вызова одних функций могут становиться аргументами для вызова других функций.
>Важно сохранять человекочитабельность кода.

```go
package main

func main() {
    d, r := div(add(25, 75), 3)         //это еще нормально
    d, r = div(add(25, 75), add(2, 1))  //такое читается уже хуже
}

func add(a, b int) int {
    return a + b
}

func div(a, b int) (int, int) {
    return a / b, a % b
}
```

#### Обычный набор возвращаемых значений

Как правило, функции возвращают ни одного, одно или два значения.
Причем одним из возвращаемых значения является
- либо булевое `ok`, являющееся признаком того, что второе значение имеет смысл,
- либо значение типа `error`, содержащее в себе информацию о возникшей
ошибке.

Подробнее об этом в специальном занятии.

```go
// функция возаращает результат деления a/b
//если b=0, ok=false, иначе ok = true
func div(a, b int) (quotient int, ok bool) {
//пока без реализации
}

//функция save что-то сохраняет
//Если неудачно это будет видно по err
func save() (err error){
// это как-то работает
}
```

## Управляющие конструкции

В отсутствие управляющих конструкций команды в блоке выполняются в соответствии с тремя правилами:
- Сверху вниз
- Подряд
- Однократно

Это **«линейный участок кода»**. Чтобы у нас появилась возможность выполнять не все команды, либо выполнять какие-то команды более, чем один раз, нам **нужны управляющие конструкции**.

- `if` без `else`
- `if` с `else`
- `if` с вызовом многозначной функции
- `switch`
- `switch` по значению
- `switch` по условию
- `default`, `fallthrough`
- Вечный `for`
- Традиционный `for`
- `break`, `continue`
- Необычные варианты `for`

### **1. `if` без `else`**

Конструкция `if` позволяет выполнять или не выполнять фрагмент кода в зависимости от значения управляющего выражения.
Управляющим выражением может быть
- `bool`-переменная,
- выражение,
- возвращающее значение `bool`,
- или функция, возвращающая значение `bool`.
  
Выражения, возвращающие `bool`, это в частности операторы сравнения:
`==` `!=` `>` `=>` `<` `<=`

В этом примере условие в выражении первого `if` не выполняется, поэтому в тело первого `if` вход выполнен не будет.

```go
var i int = 3
a := 10             //эта строка выполнится

if i > 5 {          //условие не выполняется
    a = a + 10      //этот блок будет пропущен
    fmt.Println("А ведь i больше, чем 5!")
}

a = a + 10          //эта строка выполнится, она за пределами тела if

if a <= 20 {          //это условие выполняется
    a = a + 50          //строка будет выполнена
}
```

А в тело второго `if` мы войдем, т.к. его управляющее условие выполняется.

Предположим, у нас есть функция `isCold() bool`, которая как-мто образом определяет, холодно ли сегодня. Можем её тоже использовать как управляющее выражение.

```go
if isCold() {
    fmt.Println("Сегодня холодно")
}
```

Для управляющих выражений `if` очень характерно использование логических операций `&&`, `||`, `!`

```go
if isCold() && isRainy() {
    fmt.Println("Гулять не идем")
}
```

### **2. `if` с `else`**

>`if` без `else` используется, чтобы «включить» или «выключить» фрагмент кода.

Конструкция `else` позволяет управлять выполнением сразу двух блоков, из которых выполнится лишь один.

**Соответствует дихотомии в логике**. Если управляющее выражение истинно, выполнится первый блок. Его называют `true`-блок, `true-part`.

Если управляющее выражение ложно, то выполнится `else`-блок, `else-part`.

```go
if temperature > 20 {
    fmt.Println("Тепло или жарко")
} else {
    fmt.Println("Прохладно или холодно")
}
```

#### `if` с `else`, `else if`

После `else` может идти не блок кода, а сразу еще один `if` (который будет иметь свою `true-part` и `false-part`) **Это позволяет делать каскадные проверки условий.**
Читается это не очень хорошо, но встречается часто

```go
if temperature > 20 {
    fmt.Println("Тепло или жарко")
} else if temperature > 10 {
    fmt.Println("Прохладно")
} else if temperature > 0 {
    fmt.Println("Холодно")
} else {
    fmt.Println("Вообще мороз")
}
```

Здесь последний `else` относится к `if temperature > 0`

Но это читается лучше, чем вложенные `if` одновременно в `true-part` и `false-part`. Запишем аналогичный код другим способом.
```go
if temperature > 10 {
    if temperature > 20{
        fmt.Println("Тепло или жарко")
    } else {
        fmt.Println("Прохладно")
    }
} else {
    if temperature > 0 {
        fmt.Println("Холодно")
    } else {
        fmt.Println("Мороз")
    }
}
```
Читается не очень хорошо. Возможно даже хуже.

### **3. `if` с вызовом многозначной функции**

Особый синтаксис `if` – это когда мы сначала вызываем какую-то функцию, сохранив результат её вызова, а потом строим управляющее выражение.
Представим, что у нас есть функция `div`, которая делит два числа, возвращает частное и признак того, удалось ли разделить.

```go
func div(a, b int) (quotient int, ok bool)
```

Можем её использовать прямо в `if`

```go
var cakes, kids := 6, 3

if d, ok := div(cakes, kids); ok {
    fmt.Print("Каждому ребенку достанется пирожных: ")
    fmt.Println(d)
}
```

Вызов от управляющего выражения отделяется **;**

> Важно: если переменные слева не были объявлены, то они являются локальными. Go не позволяет использовать :=, если хотя бы одна из переменных в левой части уже объявлена. В `if` ожидается либо полное объявление новых переменных, либо присваивание уже существующим.

### **4. `switch`**

Конструкция `switch` призвана использоваться в случаях, когда должна наступить одна из многих ситуаций. Можно то же самое написать при помощи `if` и `else if`, но код со
`switch` выглядит нагляднее.

Конструкция `switch` содержит несколько случаев, `case`’ов, которые проверяются подряд сверху вниз. Как только будет найден наступивший случай, остальные уже не будут
проверяться (но у этого утверждения есть свои особенности).

Существует три вида сильно отличающихся `switch`’ей, из которых мы в этой лекции рассмотрим два

### **5. `switch` по значению**

В этом случае в самом `switch`’е указывается переменная, или выражение, значение которого мы будем искать в `case`’ах.

А `case`’ы будут содержать варианты этих значений.

В зависимости от вида домашнего животного, назначим ему кличку:

```go
var pet = "собака"
var petName string

switch pet {
case "кот":
    petName = "Мурзик"

case "собака":
    petName = "Тузик"

case "попугай":
    petName = "Кеша"
}
```

Еще один пример. Можно работать с разными, почти любыми типами.

```go
func main() {

    var day = 3
    var dayName string

    switch day {
    case 1:
        dayName = "Понедельник"
    case 2:
        dayName = "Вторник"
    case 3:
        dayName = "Среда"
    case 7:
        dayName = "Воскресенье"
    }

    fmt.Println(dayName)
}
```

Интересно, что можно в одном `case`, комбинировать несколько случаев:
```go
var day = 3
var dayDescription string

switch day {
case 1, 2, 3, 4, 5:
    dayDescription = "Будний день, работаем"
case 6, 7:
    dayDescription = "Выходной, отдыхаем"
}

fmt.Println(dayDescription)
```

### **6. `switch` по условию**

Другой формат `switch`, когда каждый `case` – это самостоятельное `bool`’условие. То условие, которое выполнится первым, определит `case`, который выполнится

```go
var childAge1, childAge2 = 10, 11

switch {
case childAge1==childAge2:
    fmt.Println("Дети ровесники")
case (childAge1==childAge2-1) || (childAge2==childAge1-1):
    fmt.Println("Дети погодки")
}
```

Код внутри каждого `case` может быть и многострочным. Количество `case`’ов неограниченно.
Нужно сохранять благоразумие, чтобы не сделать код неподдерживаемым и неудобным.

### **7. `default`, `fallthrough`**

#### `default`

В конце `switch` может существовать особый случай `default`: который выполнится в том случае, если не выполнится никакой другой.
```go
var pet = "змея"
var petName string

switch pet {
case "кот":
    petName = "Мурзик"
case "собака":
    petName = "Тузик"
case "попугай":
    petName = "Кеша"
default:
    fmt.Println("Такое животное мы заводить не будем")
}

fmt.Println(petName)
```

#### `fallthrough`

Если в конце `case`’а указать ключевое слово `fallthrough`, то обработчик этого случая после завершения провалится в обработчик следующего случая. Это применяется довольно редко.
```go
var money = 10000

switch {
case money > 50000:
    fmt.Print("можем купить подарок")
    fallthrough
case money > 1000:
    fmt.Println("можем купить торт")
    fallthrough
case money > 100:
    fmt.Println("можем купить открытку")
default:
    fmt.Println("не можем купить ничего")
}
```
Каждый `fallthrouth` действует ровно на 1 следующий `case`

### **8. Вечный `for`**

В Go существует только один вид циклов – `for`. Но у него несколько различных синтаксисов, позволяющих реализовывать вечный цикл, традиционный цикл, аналог цикла `while` и некоторые экзотические варианты.

Также существует цикл `for range`, для перебирания элементов составных структур, который будет далее в следующих лекциях.

Вечный же `for` выглядит предельно просто:

```go
func main() {
    var a int

    for {
        a++
        fmt.Println(a)
    }
}
```

Блок кода, заключенный между `{ }` for называется «тело цикла». Каждое выполнение тела цикла называется «итерацией». С вечным циклом нужно быть внимательным: его возникновение может быть как следствием ошибки, так и частью правильно реализованной логики программы.

### **9. Традиционный `for`**

Традиционный `for` похож на аналогичную конструкцию в **C**.

Он состоит из трех секций:
1) действия, которое выполняется **однократно перед первой итерацией**.
2) Условия, которое проверяется **ПЕРЕД каждой итерацией**. Если условие нарушится, цикл прекратится.
3) Действия, которое выполняется **ПОСЛЕ каждой итерации**.

Следовательно, тело цикла `for` может в разных ситуациях выполняться разное количество раз, в т.ч. бесконечность (если условие не может нарушиться), в т.ч. ни разу (если условие нарушено еще перед первой итерацией).

Обычно традиционный `for` используется для приращения некоего счетчика от минимального значения до максимального. Но это не единственное его применение.

![Традиционный `for`](image/for.png)

> Важно: вторая и третьи секции "живые", т.е. если в условии или в действии после итерации стоит переменная, которая меняется в теле цикла, то эти изменения отразятся на вторую и третью секции.

> С версии 1.22 изменилась логика `for`, которая в первую очередь изменило логику `defer`, `for`, `go`

Eсть реальная управляющая переменная цикла, которая недоступна вообще, и её копии, которые создаются перед началом каждой итерации путем копирования **ИЗ** реальной в копию, и которые уничтожаются в конце итерации, но перед этим значение копии копируется В реальную переменную.
**Дальнейшая же судьба копии** - такая же, как у любой локально объявленной переменной: если она никому не нужна, она уничтожается, если же после завершения цикла она еще кому-то нужна, то будет храниться в куче, пока существуют те, кому она нужна.

### **10. `break`, `continue`**

Конструкция `break` позволяет немедленно прервать цикл. Конструкция `сontinue` позволяет немедленно прервать текущую
итерацию цикла.

Прерывание итерации – это немедленный переход на позицию «после последней строки цикла», как будто выполнение тела дошло
до конца.

```go
for i := 0; i < 10; i++ {
    if i == 3 {
        continue
    }
    if i > 6 {
        break
    }
    fmt.Println(i)
}
```

### **11. Необычные варианты `for`**

Каждое из трех составляющих выражения `for` может отсутствовать. Например отсутствие первого и последнего выражения превращает `for` в аналог `while`

```go
var i = 10

for i > 0 {
    i = i-3
    fmt.Println(i)
}
```

Также существуют варианты `for` без условия, без приращения, без инициализации и т.д.