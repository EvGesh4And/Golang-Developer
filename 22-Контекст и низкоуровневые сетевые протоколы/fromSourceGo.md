# Пакет `context`

Пакет `context` определяет тип `Context`, который переносит **крайние сроки выполнения**, **сигналы отмены** и другие значения, связанные с запросами, через границы API и между процессами.

Входящие запросы на сервер должны создавать `Context`, а исходящие вызовы к серверам должны принимать `Context`. Цепочка вызовов функций между ними должна передавать `Context`, при необходимости заменяя его на производный `Context`, созданный с использованием `WithCancel`, `WithDeadline`, `WithTimeout` или `WithValue`. Когда `Context` отменяется, отменяются также все `Context`'ы, производные от него.

Функции `WithCancel`, `WithDeadline` и `WithTimeout` принимают `Context` (родительский) и возвращают производный `Context` (дочерний) и `CancelFunc`. Вызов `CancelFunc` отменяет дочерний и его дочерние `Context`'ы, удаляет ссылку родителя на дочерний и останавливает любые связанные таймеры. Если не вызвать `CancelFunc`, дочерний `Context` и его дочерние `Context`'ы будут утекать в память до тех пор, **пока родитель не будет отменён или пока не сработает таймер**. Инструмент `go vet` проверяет, что `CancelFunc` используется во всех ветках управления.

Функция `WithCancelCause` возвращает `CancelCauseFunc`, который принимает ошибку и сохраняет её как причину отмены. Вызов `Cause` на отменённом `Context` или любом его потомке возвращает эту причину. Если причина не указана, `Cause(ctx)` возвращает то же значение, что и `ctx.Err()`.

Программы, использующие `Context`, должны следовать следующим правилам, чтобы интерфейсы оставались единообразными во всех пакетах, и чтобы инструменты статического анализа могли проверять передачу `Context`'ов:

- Не храните `Context` внутри структур. Вместо этого передавайте его явно каждой функции, которая в нём нуждается. `Context` **должен быть первым параметром**, обычно называемым `ctx`:

```go
func DoSomething(ctx context.Context, arg Arg) error {
    // ... использовать ctx ...
}
```

- Не передавайте `nil` как `Context`, даже если функция это допускает. Используйте `context.TODO`, если не уверены, какой `Context` использовать.

- Используйте значения `context` только для данных, привязанных к запросу и передающихся между процессами и API, а не для передачи необязательных параметров в функции.

- Один и тот же `Context` может передаваться в функции, работающие в разных горутинах. `Context` **безопасен для одновременного использования несколькими горутинами**.

Примеры кода сервера, использующего Context, можно найти по адресу:
https://blog.golang.org/context

## Интерфейс Context

`Context` переносит крайний срок, сигнал отмены и другие значения через границы API.

Методы `Context` могут вызываться несколькими горутинами одновременно.

### `Deadline() (deadline time.Time, ok bool)`
Deadline возвращает время, когда работа, выполняемая от имени этого `Context`, должна быть отменена. Возвращает `ok == false`, если крайний срок не установлен. Последующие вызовы возвращают те же результаты.

### `Done() <-chan struct{}`
`Done` возвращает канал, который закрывается, когда работа от имени этого `Context` должна быть отменена. Может вернуть `nil`, если этот `Context` не может быть отменён. Последующие вызовы возвращают одно и то же значение. Закрытие канала `Done` может произойти асинхронно, после возврата функции отмены.

`WithCancel` организует закрытие Done при вызове `cancel`;
`WithDeadline` — когда истекает крайний срок;
`WithTimeout` — когда истекает тайм-аут.

`Done` используется в операторах `select`.
Пример:

```go
// Stream генерирует значения с помощью DoSomething и отправляет их в out,
// пока DoSomething не вернёт ошибку или пока ctx.Done не будет закрыт.
func Stream(ctx context.Context, out chan<- Value) error {
	for {
		v, err := DoSomething(ctx)
		if err != nil {
			return err
		}
		select {
		case <-ctx.Done():
			return ctx.Err()
		case out <- v:
		}
	}
}
```

Больше примеров использования `Done`-канала для отмены:
https://blog.golang.org/pipelines

`Err() error`
Если Done ещё не закрыт, возвращает `nil`.
Если Done закрыт, возвращает ненулевую ошибку, объясняющую причину:
- `Canceled`, если `Context` был отменён
- `DeadlineExceeded`, если истёк крайний срок.

После того как `Err` вернёт ошибку, последующие вызовы возвращают ту же ошибку.

`Value(key any) any`
Возвращает значение, связанное с этим `Context` по ключу, или nil, если значения нет. Последующие вызовы с тем же ключом возвращают тот же результат.

Используйте значения `context` только для данных, привязанных к запросу, которые переходят между процессами и API, а не для передачи необязательных параметров в функции.

Ключ определяет конкретное значение в `Context`.
Функции, сохраняющие значения в `Context`, обычно выделяют ключ в глобальной переменной и используют его в качестве аргумента в `context.WithValue` и `Context.Value`. Ключом может быть любой тип, поддерживающий сравнение на равенство. Пакеты должны определять ключи как непубличные типы, чтобы избежать конфликтов.

Пакеты, определяющие ключи `Context`, должны предоставлять безопасные для типов функции-доступоры к значениям:

```go
// Пакет user определяет тип User, который сохраняется в Context.
package user

import "context"

// User — это тип значения, хранимого в Context.
type User struct { ... }

// key — непубличный тип для ключей, определённых в этом пакете.
// Это предотвращает конфликты с ключами из других пакетов.
type key int

// userKey — ключ для значений user.User в Context. Он непубличный;
// пользователи используют user.NewContext и user.FromContext
// вместо использования ключа напрямую.
var userKey key

// NewContext возвращает новый Context, содержащий значение u.
func NewContext(ctx context.Context, u *User) context.Context {
	return context.WithValue(ctx, userKey, u)
}

// FromContext возвращает значение User, хранящееся в ctx, если оно есть.
func FromContext(ctx context.Context) (*User, bool) {
	u, ok := ctx.Value(userKey).(*User)
	return u, ok
}
```