# Работа с NoSQL

## Маршрут вебинара

- Обзор концепции NoSQL
- Redis, MongoDB, Aerospike
- Практика

## Цели вебинара

1. Изучить особенности работы с NoSQL
2. Изучить подходы работы с MongoDB и другими NoSQL

## Концепция NoSQL

### Реестр баз данных

[Ссылка](https://db-engines.com/en/ranking)

![alt text](images/image.png)

### Обзор концепции NoSQL

NoSQL (Not Only SQL) — это подход к хранению и обработке данных, который не ограничивается схемой данных и позволяет более свободно управлять информацией.

![alt text](images/image-1.png)

NoSQL — это не конкретная технология, а семейство различных подходов к хранению
данных.

![alt text](images/image-2.png)

### Основные отличия NoSQL БД от реляционных
1. гибкая схема данных
2. горизонтальное масштабирование
3. поддержка разных моделей данны (ключ-значение, документы, столбцы и др.)
4. отсутсвтие языка запросов (SQL)

![alt text](images/image-3.png)

### Примеры NoSQL БД

[Статья](https://habr.com/ru/companies/amvera/articles/754702/)

![alt text](images/image-4.png)

### Когда использовать NoSQL БД

- Хранение и обработка больших объемов данных
- Проекты, где структура данных меняется часто
- Работа с неструктурированными данными
- Кэширование и обработка очередей
- Проект, где необходимо горизонтальное масштабирование

## MongoDB

MongoDB — это популярная NoSQL БД, основанная на документах.

Она позволяет хранить данные в формате JSON-подобных документов и обеспечивает высокую производительность.

![alt text](images/image-5.png)

### Основные понятия

- Коллекция — это группа документов, которые хранятся в MongoDB. Коллекции аналогичны таблицам в реляционных БД.
- Документ: Записи данных в формате BSON (бинарный JSON).
- Поля: Каждый документ содержит набор пар ключ-значение.
- Индексы: Ускоряют поиск данных.

![alt text](images/image-6.png)

### Работаем с MongoDB локально через Docker

Запускаем контейнер с сервером MongoDB:

```bash
docker run -d \
    --name mongo \
    -e MONGO_INITDB_ROOT_USERNAME=admin \
    -e MONGO_INITDB_ROOT_PASSWORD=password123 \
    -p 27017:27017 \
    mongo
```

Ждём немного, пока Mongo поднимется 
Подключаемся к серверу:

```bash
docker exec -it mongo mongo --username admin --password password123
--authenticationDatabase admin
```

### Работаем с MongoDB в Go

```go
// Контекст с таймаутом
ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
defer cancel()

// Подключение к MongoDB
clientOptions := options.Client().ApplyURI("mongodb://admin:password123@192.168.1.20:27017/admin")
client, err := mongo.Connect(ctx, clientOptions)
if err != nil {
	log.Fatal(err)
}

// Пинг сервера для проверки соединения
err = client.Ping(ctx, nil)
if err != nil {
	log.Fatal(err)
}

fmt.Println("Подключено к MongoDB!")

// Создание или переключение на базу данных
dbName := "mydb"
db := client.Database(dbName)
// Создание коллекции
collectionName := "mycollection"
collection := db.Collection(collectionName)
// Удаление коллекции
if err := collection.Drop(context.Background()); err != nil {
 log.Fatal(err)
}
// Удаление базы данных
if err := client.Database(dbName).Drop(context.Background()); err != nil {
 log.Fatal(err)
}
// Закрытие соединения с MongoDB
if err := client.Disconnect(context.Background()); err != nil {
 log.Fatal(err)
}
```

```go
// Вставка документа
_, err = collection.InsertOne(context.Background(), bson.M{"name": "John Doe"})
var result bson.M
err = collection.FindOne(context.Background(), bson.M{"name": "John Doe"}).Decode(&result)
// Создание индекса на поле
indexModel := mongo.IndexModel{
 Keys: bson.D{{Key: "name", Value: 1}}, // Создание восходящего индекса на поле "name"
 Options: options.Index().SetUnique(true), // Сделать индекс уникальным
}
// Создание индекса в коллекции
_, err = collection.Indexes().CreateOne(context.Background(), indexModel)
```

## Redis

![alt text](images/image-7.png)

Redis — это высокопроизводительная система управления данными, которая предоставляет быстрое хранение и доступ к данным.

Redis является NoSQL базой данных, но также часто используется для курирования и управления сообществами в системах очередей.

### Особенности Redis
1. Все данные хранятся в оперативной памяти
2. Однопоточность
3. Хранилище «ключ-значение»
4. Разнообразные типы и структуры данных
    ○ строки
    ○ хэш-таблицы
    ○ списки
    ○ множества
    ○ упорядоченные множества
    ○ и т.д.

### 1. Архитектура Redis

**Особенности:**
- вся база Redis — это один большой словарь "ключ-значение"
- команды для работы с данными очень простые, в основном — установка / получение значения

![alt text](images/image-8.png)

**Как следствие:**
- в Redis нет внешних ключей, JOIN, подзапросов…
- обычный сценарий — сделать несколько запросов вместо одного

![alt text](images/image-9.png)

### 2. Типы данных в Redis

**Особенности:**
- все знаùения хранятся как строки
- если строка содержит число, становятся доступные дополнительные команды (инкрементация и т.д.)

**Как следствие:**
- значения других типов (булевый, составные и т.д.) нужно приводить к строкам на клиенте

![alt text](images/image-10.png)

### 3. Время жизни данных в Redis

**Особенности:**
● для любого ключа можно указать время его жизни (TTL)
● по истечении этого времени и ключ, и значение будут автоматически удалены
Как следствие:
● с разработчиков снимается часть головной боли

![alt text](images/image-11.png)

### Типы данных: Строки

- хранятся в "глобальных" ключах
- время доступа к значению: `O(1)`
- размер значения до 512 Mb
- значения бинарно-безопасны

![alt text](images/image-12.png)

```
SET user:1:name "Dmitry"    # Установить значение
GET user:1:name             # Получить значение

SET upload:counter 10       # Установить значение (число)
INCR upload:counter         # Инкрементировать значение числа

SET cache:api "json" EX 10  # Установить значение с TTL 10 сек
TTL cache:api               # Проверить TTL ключа
GET cache:api               # Если ключа нет, GET вернёт (nil)

DEL upload:counter          # Удалить ключ

KEYS user*                  # Вывести список ключей по шаблону
KEYS *
```

**Сценарии использования:**
- кэширование
- хранение сессий
- атомарные счетчики
- Mutex
- Rate-limit

**Пара слов о ключах в Redis:**
● аналог ключа в словаре или ассоциативном массиве
● название ключа может быть любым, Redis никак его не анализирует

**Как их называть:**
● осмысленное название
● идём от общего к частному
● `user:12:token`
● двоеточия в имени ключа нужны только для человека

![alt text](images/image-13.png)

**Основные проблемы строк:**
● для больших сущностей нужна уйма ключей
● обработку приходится переносить на клиент

![alt text](images/image-14.png)

### Типы данных: Хэш-таблицы

- аналог вложенных ассоциативных массивов
- время доступа к значениям внутри таблиц: `O(1)`
- отсутствует вложенность (только 1 уровень)
- нет схемы данных

![alt text](images/image-15.png)

```
HSET user:1 name "Dmitry"   # Установить значение
HSET user:1 age 40

HGET user:1 name            # Получить значение поля
HSET user:1 name "Ivan"     # Изменить значение
HINCRBY user:1 age 1        # Инкрементировать значение

HGETALL user:1              # Получить пары «полезначение»
HKEYS user:1                # Получить все поля
HVALS user:1                # Получить все значения

HDEL user:1 age             # Удалить одно поле
DEL user:1                  # Удалить всю хэш-таблицу
```

**Сценарии использования**
- хранение составных объектов
- как правило, используется в связке с другими типами

**Важно помнить:**
- внешних ключей в Redis нет
- индексов, поиска и сортировки для хэш-таблиц тоже нет (нужны доп. модули)
- многие задачи решаются несколькими запросами

**Проблема: хранение списков**
- строки и хэш-таблицы плохо подходят для хранения последовательных списков
- мы можем быстро получить доступ к элементу по ключу
- но у нас будут сложности при переборе, удалении, добавлении...

![alt text](images/image-16.png)


### Типы данных: Списки

- под капотом связные списки
- время доступа в начало/конец: `O(1)`
- время произвольного доступа (в т.ч. поиск): `O(N)`
- могут содержать **неуникальные** значения


![alt text](images/image-17.png)

```
RPUSH user:1:posts post:10  # Добавить элемент в конец
RPUSH user:1:posts post:11
RPUSH user:1:posts post:12

LPUSH user:1:posts post:9   # Добавить элемент в начало
LTRIM user:1:posts 0 2      # Обрезать список до 3 эл-тов

LLEN user:1:posts           # Получить длину списка
LRANGE user:1:posts 0 10    # Получить срез списка
LINDEX user:1:posts 0       # Получить элемент по индексу

RPOP user:1:posts           # Удалить элемент с конца
LPOP user:1:posts           # Удалить элемент с начала
```

Сценарии использования:
- хранение событий в хронологическом порядке
- логирование
- event sourcing

Важно помнить:
- список со временем будет раздуваться
- частая практика — обрезать его длину после вставки

```
LPUSH user:1:posts post:22
LTRIM user:1:posts 0 9
```

### Типы данных: Множества

- содержат только **уникальные** значения
- **не сортированы**
- время добавления значения: `O(1)`
- время проверки существования значения: `O(1)`

**Сценарии использования:**
- аналитика
- хранение связей между сущностями
- таксономия (тэги)

```
SADD users:online user:1    # Добавить элемент
SADD users:online user:2
SADD users:online user:12

SADD users:online user:12   # Дубликат: мн-во не изменится
SCARD users:online          # Получить мощность множества
SMEMBERS users:online       # Получить элементы множества

SREM users:online user:2    # Удалить элемент из множества
```

Над множествами можно выполнять операции.
Результат любой операции — новое множество

![alt text](images/image-19.png)

```
SDIFF users:all users:online        # Разность
SINTER users:online users:premium   # Пересечение
SUNION users:premium users:vip      # Объединение
```

### Типы данных: Упорядоченные множества


- содержат только уникальные значения
- для каждого значения указывается счёт (score)
- значения автоматически сортируются по счёту
- время добавления и поиска — `O(log(n))`

![alt text](images/image-20.png)

```
ZADD users:rating 10 user:1         # Добавить элемент
ZADD users:rating 5 user:2
ZADD users:rating 15 user:12
ZADD users:rating 15 user:12        # Дубликат: мн-во не изменится

ZCARD users:rating                  # Получить мощность множества
ZCOUNT users:rating 5 10            # Кол-во эл-тов в диапазоне
ZRANGE users:rating 5 10 BYSCORE    # Получить эл-ты в диапазоне

ZRANK users:rating user:12          # Получить место эл-та в мн-ве
ZREM users:rating user:12           # Удалить элемент из множества
```

**Сценарии исполþзованиā**
- рейтинги
- аналог индекса в РСУБД (значение — ключ сущности)

**Важно помнить:**
- для вывода в порядке убывания используются zrev*
- если обновить рейтинг, он перезапишет старый

### Транзакции

```
MULTI       # Начало транзакции

SET t1 "a"  # Эти команды не выполняются,
SET t2 10   # а ставятся в очередь
INCR t2

EXEC        # Фиксация транзакции    
```

```
MULTI       # Начало транзакции

SET t1 "a"  # Эти команды не выполняются,
SET t2 10   # а ставятся в очередь
INCR t2

DISCARD     # Отмена транзакции
```

### Redis для кэширования

Redis часто используется в качестве системы кэширования для ускорения доступа к данным. Кэш Redis хранит часто запрашиваемые данные в памяти, что позволяет уменьшить нагрузку на базу данных и ускорить ответы на запросы.

![alt text](images/image-21.png)

### Redis как брокер сообщений

Redis может использоваться в качестве брокера сообщений для реализации очередей сообщений и управления асинхронными задачами.

![alt text](images/image-22.png)

### Применение в Go

```go
// Кеширование данных
client.Set(ctx, "username", "john_doe", 0).Err()
if err != nil {
    fmt.Println("Ошибка при кешировании данных:", err)
    return
}
// Получение данных из кеша
username, err := client.Get(ctx, "username").Result()
if err != nil {
    fmt.Println("Ошибка при получении данных из кеша:", err)
    return
}
// Отправка сообщения в очередь
err := client.LPush(ctx, queueName, message).Err()
// Получение сообщения из очереди (блокирующая операция)
message, err := client.BRPop(ctx, 0, queueName).Result()
```

```go
// Публикация сообщения для подписчиков
err := rdb.Publish(ctx, "mychannel", fmt.Sprintf("Hello, Redis! {%d}", n)).Err()
// Подписка на канал
pubsub := rdb.Subscribe(ctx, "mychannel")
defer pubsub.Close()
// Чтение сообщений из канала
ch := pubsub.Channel()
for msg := range ch {
    fmt.Printf("{%s} Получено сообщение: %s\n", name, msg.Payload)
}
```

