---
marp: true
theme: default
class: invert
paginate: true
---

# Горутины и каналы


## Цели занятия

* понимать основы конкурентности в Go;

* начать работу с горутинами и каналами

---

## Краткое содержание

* горутины и каналы;

* сравнение буферизированных и небуферизованных каналов;

* использование каналов для передачи данных и синхронизации;

* оператор **select**

---

## Конкурентность (Concurrency) и параллелизм (Parallelism)

* Конкурентность - способ организации кода, архитектура
    
    Конкурентность — это способность программы или системы запускать несколько задач одновременно, но не обязательно параллельно. В условиях конкурентности задачи могут выполняться последовательно (в одно время) или же переключаться между собой, создавая впечатление одновременной работы. Конкурентная программа может использовать один процессор, но при этом выполнять несколько задач, «переключаясь» между ними, используя, например, многозадачность операционной системы.

        Пример:
            Операционная система может переключать между задачами, чтобы дать возможность каждой из них выполнить некоторое количество работы. При этом задачи могут работать на одном ядре процессора, поочередно используя его.

* Параллелизм - одновременное выполнение несколькими исполнителями
    
    Параллелизм — это процесс, при котором несколько задач выполняются одновременно, что возможно при наличии нескольких процессоров или ядер. Параллельная программа использует несколько процессоров или ядер для выполнения разных частей задачи одновременно.

        Пример:
            Программа, которая выполняет вычисления на разных ядрах процессора, выполняет несколько задач параллельно.

### Различия:
    
- Конкурентность ориентирована на правильную координацию задач и управление их выполнением (например, синхронизация).

- Параллелизм ориентирован на выполнение задач одновременно, что может быть реализовано с помощью многопроцессорных систем или многозадачности.


[Перевод статьи Роба Пайка](https://habr.com/ru/articles/761754/) (или смотри в другом файле)

---

## Конкурентность в Go

* Go обладает выразительными средствами для написания конкурентного кода
* Go поддерживает параллельное исполнение кода
* весь код в Go выполняется в горутинах (в тч `main`)
* запуск новой горутины:

```go
go func(){

// ...

}() // <- скобки в конце
```

---

```go
go func(){ ... }() 

go myfunc(a,b,c)

go myStruct.MyFunc()
```

---

## See code A

### Разбор кода с горутинами

В этом коде мы имеем несколько горутин, которые выполняются конкурентно. Рассмотрим шаги выполнения программы:

1. **Запуск программы (основная горутина):**
   Когда выполняется функция `TestGoroutine1`, запускается основная горутина. Это первая горутина, которая начинает выполнение кода.

2. **Определение функции `buzz`:**
   Внутри функции `TestGoroutine1` вы определяете функцию `buzz`, которая выполняет цикл с выводом строки и задержкой в 1 секунду.

3. **Запуск второй горутины:**
   В основной горутине вы создаете новую горутину с помощью ключевого слова `go`. Внутри этой горутины будет вызвана функция `buzz` с аргументом `"gorut"`. Это создает **вторую горутину**.

4. **Выполнение функции `buzz` в основной горутине:**
   После запуска второй горутины, в основной горутине продолжается выполнение функции `buzz` с аргументом `"main"`. Таким образом, у вас есть две горутины, которые выполняются конкурентно.

5. **Завершение программы:**
   После того как обе горутины выполнят свои задачи, программа завершится. Однако важно отметить, что **основная горутина не ожидает завершения подчиненной** горутины. Если бы программа завершалась сразу после выполнения `buzz("main")`, подчиненная горутина могла бы не успеть завершиться, но так как в коде есть задержки, горутина `"gorut"` успевает завершиться до завершения программы.

6. **Количество горутин:**
   Вызов `runtime.NumGoroutine()` в конце выводит количество активных горутин в момент вызова. Так как существует основная горутина и одна подчиненная горутина, этот вызов выведет значение 2.


### Почему три горутины?

1. Основная горутина, которая выполняет `TestGoroutine1`.
2. Подчиненная горутина, которая выполняет `buzz("gorut")`.
3. **Внутренние системные горутины Go** — Go создает дополнительные горутины для работы с системными задачами, такими как управление планировщиком или сборщик мусора. Эти горутины обычно скрыты от пользователя и не всегда видны в коде.

Таким образом, результат `runtime.NumGoroutine()` может быть 3, потому что система может создать дополнительные горутины для своих внутренних задач.


### Сводка:

- У вас **две явные горутины**: одна для `"main"`, другая для `"gorut"`.
- Дополнительная **системная горутина** создается автоматически Go.
- Всего получится 3 горутины, даже если вы создаете только две.

---

## Горутины дёшевы


"Стандартный" способ реализации параллелизма — потоки (threads) ОС.

Go использует подход "кооперативной многозадачности" чтобы повторно использовать "дорогие" потоки OC для запуска сотен тысяч горутин.

* Параллелизм — столько сколько ядер

* Конкурентность — миллионы


### "Стандартный" способ реализации параллелизма

В традиционных языках программирования для реализации параллелизма используется **потоки (threads)** операционной системы. Каждый поток — это отдельная единица выполнения, которая может быть выполнена параллельно на различных ядрах процессора.

### Подход Go: кооперативная многозадачность

Go использует другой подход, называемый **кооперативной многозадачностью**. Вместо того чтобы запускать один поток для каждой задачи, Go позволяет запускать **сотни тысяч горутин** на ограниченном количестве потоков операционной системы. Это позволяет эффективно использовать ресурсы и минимизировать накладные расходы на создание и переключение потоков.

### Разница между параллелизмом и конкурентностью

- **Параллелизм**: это ситуация, когда задачи выполняются одновременно на разных ядрах процессора. В Go это означает, что количество параллельно выполняющихся горутин ограничено количеством ядер на машине. Таким образом, параллелизм в Go ограничен числом доступных ядер процессора.

- **Конкурентность**: это ситуация, когда задачи могут выполняться одновременно, но они могут чередоваться на одном или нескольких процессорах, в зависимости от планировщика. В Go вы можете создать **миллионы горутин**, которые будут работать конкурируя за процессорное время. Планировщик Go будет переключать выполнение горутин, что дает иллюзию параллельного выполнения, даже если фактически выполняется меньше горутин, чем ядер процессора.

Таким образом:
- **Параллелизм** в Go ограничен количеством ядер процессора.
- **Конкурентность** позволяет запускать миллионы горутин, которые могут работать конкурируя друг с другом.

---

## See code B

**Разбор кода:**

1. `runtime.GOMAXPROCS(1)` ограничивает число доступных ядер одним.
2. `runtime.NumCPU(), runtime.GOMAXPROCS(0)` — выводит число доступных в системе ядер и число ядер, предоставленных Go для выполнения горутин.
3. Создаются 10 горутин.
4. Главная горутина уходит в сон на одну секунду `(time.Sleep(1 * time.Second))`.
5. В это время на одном ядре поочередно выполняются горутины из пула.
6. Выполняются последовательно, так как нет поводов для переключения горутин (они заняты вычислениями без блокировки).
7. Если раскомментировать `runtime.Gosched()`, то это позволит планировщику Go переключить выполнение на другую горутину.
8. `time.Sleep(1 * time.Millisecond)` является индикатором для планировщика, что данная горутина будет неактивна, и можно безопасно переключиться на другую.

**Итог:**

- Конкурентность: Все горутины запускаются, но выполняются поочередно, так как у нас только одно доступное ядро.

- Параллелизм: Если увеличить `runtime.GOMAXPROCS(n)`, где `n > 1`, тогда горутины начнут выполняться параллельно на нескольких ядрах.

---

## Управление горутинами


Go представляет несколько способов управления горутинами:

* примитивы синхронизации

* каналы

**Сегодня рассматриваем каналы**.



См так же:

* https://go101.org/article/channel.html

---

## See code C

---

## буферизированные каналы


Мы рассмотрели каналы без буферов.

Можно создать буферизированный

```go
ch := make(chan int, 10)

ch <- 0

cap(ch) // 10

len(ch) // 1
```

---

## See code D

---
## select

используется если надо одновременно ждать сигнал от нескольких каналов


```go
select{

case a := <- results: // ...

case <- timeout: // ...

}
```

---
## select and send

еще select можно использовать для отправки в каналы

---

## See code E

---

## close

* закрывает ТОЛЬКО источник (тот кто шлёт)

* всё ожидания прерываются, `for ... range` - завершается

---

## directed channels

## See code F

---

## chan - ref or value?

## See code G

