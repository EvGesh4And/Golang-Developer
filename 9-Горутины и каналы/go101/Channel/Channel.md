# Channels in Go

[Статья](https://go101.org/article/channel.html)

Каналы — это один из ключевых встроенных механизмов в Go, делающий его уникальным. В сочетании с горутинами (goroutine) каналы (channel) значительно упрощают работу с конкурентным программированием (concurrent programming), делая его удобным и даже увлекательным.

Канал в основном выступает в качестве метода [синхронизации конкурентности](https://go101.org/article/control-flows-more.html#synchronization). В этой статье будут перечислены все концепции, синтаксис и правила, связанные с каналом. Чтобы лучше понять каналы, также просто описывается внутренняя структура каналов и некоторые детали реализации стандартным компилятором/средой выполнения Go.

Информация в этой статье может быть немного сложной для новых сусликов. Некоторые части этой статьи, возможно, придется прочитать несколько раз, чтобы полностью понять.

## Введение в каналы (Channel Introduction)

Одно из предложений (сделанное *Робом Пайком*) по конкурентному программированию звучит так:
> **"Не (позволяйте вычислениям) обмениваться данными, совместно используя память, (позвольте им) совместно использовать память, обмениваясь данными (по каналам)."**  
> *("Don't (let computations) communicate by sharing memory, (let them) share memory by communicating (through channels)")*

(В контексте Go каждое вычисление можно рассматривать как горутину.)

**Использование общей памяти для обмена данными** и **обмен данными для совместного использования памяти** — это два разных подхода к конкурентному программированию. Когда горутины обмениваются данными через общую память, применяются традиционные методы синхронизации, такие как мьютексы, для защиты общей памяти и предотвращения гонки данных. Однако можно использовать каналы, чтобы реализовать второй подход — обмен данными для совместного использования памяти.

Go предоставляет уникальный механизм синхронизации — **каналы (channel)**. Каналы позволяют горутинам совместно использовать память через обмен данными. Канал можно представить как внутреннюю очередь **FIFO (первым пришел — первым вышел)** внутри программы. Одни горутины отправляют в канал значения, а другие получают их.

Помимо передачи самих значений через каналы, между горутинами может передаваться и владение этими значениями. Когда горутина отправляет значение в канал, можно рассматривать это как освобождение ею владения значением (которое могло быть доступно через переданное значение). Соответственно, когда другая горутина получает это значение из канала, можно рассматривать это как приобретение владения значением.

Разумеется, не во всех случаях передача данных через канал означает передачу владения. Значения, владение которыми передается, часто (но не обязательно) представляют собой ссылки. Важно понимать, что речь идет о логическом владении. Каналы в Go помогают писать код без гонки данных, но не предотвращают возможность написания неэффективного или некорректного конкурентного кода.

**Хотя Go поддерживает и традиционные методы синхронизации, только каналы являются полноценным элементом языка.** Каналы — это отдельный тип данных в Go, поэтому их можно использовать без подключения дополнительных пакетов. В то же время традиционные механизмы синхронизации реализованы в стандартных пакетах `sync` и `sync/atomic`.

Каждый механизм синхронизации лучше всего подходит для определенных сценариев. Однако каналы обладают широкими возможностями применения и большим разнообразием способов использования. Одна из проблем каналов в том, что программирование с их использованием настолько удобное и приятное, что разработчики могут применять их даже там, где они не являются наилучшим решением.

## Типы и значения каналов

Как и массивы, срезы и отображения (map), каждый тип канала имеет тип элементов. Канал может передавать только значения этого типа.

Каналы бывают двунаправленными и однонаправленными. Пусть `T` — произвольный тип:

1. `chan T` обозначает двунаправленный канал. Компилятор разрешает и отправку, и получение значений из таких каналов.
2. `chan<- T` обозначает канал только для отправки (send-only). Компилятор не позволяет получать значения из таких каналов.
3. `<-chan T` обозначает канал только для получения (receive-only). Компилятор не позволяет отправлять в него значения.

`T` называется типом элементов этих каналов.

Значения двунаправленного типа `chan T` могут неявно преобразовываться как в `chan<- T`, так и в `<-chan T`, но обратное преобразование невозможно, даже явно. Значения типа `chan<- T` нельзя преобразовать в `<-chan T` и наоборот.
Следует отметить, что `<-` в объявлениях типов каналов является модификатором, а не оператором.

Каждое значение канала имеет емкость (capacity), которая будет рассмотрена в следующем разделе.

* Канал с емкостью 0 называется небуферизованным (unbuffered).
* Канал с емкостью больше 0 называется буферизованным (buffered).

Значения по умолчанию (zero values) для типов каналов представлены предопределенным идентификатором nil.
Чтобы создать не nil канал, необходимо использовать встроенную функцию make.

Пример:
```go
make(chan int, 10)
```

Этот вызов создаст канал с типом элементов int и емкостью 10.

Второй аргумент в make задает емкость канала. Он необязательный; если его не указать, емкость будет равна 0.

## Сравнение значений каналов

Все типы каналов в Go являются сравнимыми (comparable).

Из статьи [value parts](https://go101.org/article/value-part.html) мы знаем, что значения канала, отличные от nil, являются значениями, состоящими из нескольких частей. Если одно значение канала присваивается другому, то оба канала используют одну и ту же базовую часть. Другими словами, эти два канала представляют один и тот же объект внутреннего канала. Результатом их сравнения является `true`.

## Операции с каналами
В Go определено пять операций для работы с каналами. Пусть `ch` — некоторый канал, тогда:

1. Закройте канал, используя следующий вызов функции
	```go
	close(ch)
	```
	где `close` - это встроенная функция. Аргументом вызова функции `close` должно быть значение канала, а канал `ch` не должен быть каналом только для приема (`<-chan T`).

2. Отправьте значение `v` в канал, используя следующий синтаксис
	```go
	ch <- v
	```
	где `v` должно быть значением, которое может быть присвоено типу элемента канала `ch`, и канал `ch` не должен быть каналом только для приема (`<-chan T`). Оператор `<-` здесь — **оператор отправки**.

3. Получение значения из канала с помощью следующего синтаксиса

	```go
	<-ch
	```

	Операция получения по каналу всегда возвращает по крайней мере один результат, который является значением типа элемента канала, и канал `ch` не должен быть каналом только для отправки (`chan<- T`). Оператор `<-` в этом случае — **оператор получения**.

	В большинстве случаев получение значения из канала используется как выражение с одним значением:
	```go
	v = <-ch
	```
	Однако, когда операция с каналом используется в качестве единственного исходного значения в присваивании, результатом может быть второе необязательное нетипизированное логическое значение и выражение может быть многозначным.
	
	Однако, если канал закрыт, можно проверить, было ли значение отправлено **до закрытия**:
	```go
	v, sentBeforeClosed = <-ch
	```
	Здесь `sentBeforeClosed` — булево значение, которое равно `false`, если канал был закрыт и больше в нем нет данных.
	(Ниже мы узнаем, что мы можем получать неограниченное количество значений из закрытого канала.)

4. Получение емкости канала
	```go
	cap(ch)
	```
	где `cap` - это встроенная функция, которая когда-либо была представлена в [контейнерах в Go](https://go101.org/article/container.html#cap-len). Результатом вызова функции `cap` является значение `int`.
5. Получение текущей длины канала
   	```go
   	len(ch)
	```
	где `len` - это встроенная функция, которая также когда-либо использовалась ранее. Возвращаемое значение при вызове функции `len` - это значение типа `int`. Результирующая длина - это количество элементов, которые уже были успешно отправлены в запрошенный канал, но еще не были получены (извлечены).

Большинство базовых операций в Go не являются синхронизированными. Другими словами, они не являются потокобезопасными ( они не являются безопасными с точки зрения конкурентности). К таким операциям относятся
- присваивание значений,
- передача аргументов,
- манипуляции с элементами контейнеров и т. д.
Однако все представленные операции с каналами уже синхронизированы, поэтому дополнительная синхронизация не требуется для безопасного выполнения этих операций.

Как и большинство других операций в Go, присваивание значений каналов не является синхронизированным. Аналогично, присваивание полученного из канала значения другой переменной также не является синхронизированным, хотя сама операция получения значения из канала синхронизирована.

Если проверяемый канал является `nil`-каналом, то встроенные функции `cap` и `len` вернут ноль. Эти две операции настолько просты, что не будут подробно рассматриваться позже. Фактически, на практике они используются редко.

Операции отправки, получения и закрытия каналов будут подробно рассмотрены в следующем разделе.

## Подробные объяснения операций с каналами

Чтобы сделать объяснения операций с каналами простыми и понятными, в оставшейся части статьи каналы будут разделены на три категории:

1. `nil`-каналы.
2. Не `nil`, но закрытые (closed) каналы.
3. Не закрытые не `nil`-каналы.

В следующей таблице кратко суммированы поведения всех видов операций, применяемых к `nil`, закрытым и не закрытым не `nil`-каналам.

| Операция           | `nil`-канал   | закрытый канал | не закрытый не `nil`-канал |
|--------------------|--------------|---------------|----------------------------|
| `close(ch)`        | panic        | panic        | succeed to close (*C*)          |
| send `ch <- v`     | block forever | panic        | block or succeed to send (*B*)  |
| receive `v <- ch`  | block forever | never block (*D*)  | block or succeed to receive (*A*) |

Для пяти случаев, показанных без индексов, поведение каналов очевидно:

1. Закрытие `nil`-канала или уже закрытого канала вызывает панику в текущей горутине.
2. Отправка значения в закрытый канал также вызывает панику в текущей горутине.
3. Отправка значения в `nil`-канал или получение значения из `nil`-канала приводит к вечной блокировке текущей горутины.

Далее будут даны дополнительные объяснения для четырех случаев, помеченных индексами (*A*, *B*, *C* и *D*).

Чтобы лучше понять типы и значения каналов, а также упростить объяснение некоторых аспектов их работы, полезно рассмотреть их внутренние структуры.

Мы можем представить каждый канал как состоящий из трех очередей (все они могут быть рассмотрены как FIFO-очереди) на внутреннем уровне:

1. **receiving goroutine queue (RGQ)** Очередь горутин для получения (обычно FIFO). Эта очередь представляет собой связанный список без ограничения по размеру. Горутинки в этой очереди находятся в заблокированном состоянии и ожидают получения значений из канала.

2. **sending goroutine queue (SGQ)** Очередь горутин для отправки (обычно FIFO). Эта очередь также представляет собой связанный список без ограничения по размеру. Горутинки в этой очереди находятся в заблокированном состоянии и ожидают отправки значений в канал. Значение (или адрес значения, в зависимости от реализации компилятора), которое каждая горутина пытается отправить, также хранится в очереди вместе с этой горутиной.

3. **value buffer queue (VBQ)** Очередь буфера значений (абсолютно FIFO). Это кольцевая очередь. Ее размер равен емкости канала. Типы значений, хранящихся в этой очереди, соответствуют элементам типа канала. Если текущее количество значений в буфере значений канала достигает емкости канала, канал считается "полным". Если в буфере нет значений, канал считается "пустым". Для канала с нулевой емкостью (небуферизованный) он всегда находится и в состоянии полного, и в состоянии пустого.

Каждый канал внутренне содержит мьютекс для предотвращения гонок данных при выполнении различных операций.

### Операция с каналом — случай *A*
<u> Когда горутина **R** пытается **получить** значение из не закрытого и не nil-канала </u>, горутина **R** получает блокировку, связанную с каналом, а затем выполняет следующие шаги до тех пор, пока одно из условий не будет выполнено:

1. Если очередь буфера значений канала (**VBQ**) **не пуста** (в этом случае очередь горутин для получения канала (**RGQ**) должна быть **пуста**), горутина **R** получает (сдвигает) значение из буфера значений канала. Если очередь горутин для отправки канала (**SGQ**) также не пуста, то из нее сдвигается горутина, и она возобновляется в рабочем состоянии. Значение, которое эта отправляющая горутина пыталась отправить, будет помещено в очередь буфера значений канала (**VBQ**). После этого горутина **R** продолжает выполнение. В этом случае операция получения из канала называется **неблокирующей (non-blocking operation)**.

2. Если очередь буфера значений (**VBQ**) **пуста**, и если очередь горутин для отправки канала (**SGQ**) **не пуста** (в этом случае канал должен быть небуферизированным), горутина **R** сдвигает отправляющую горутину из очереди горутин для отправки канала и получает значение, которое эта отправляющая горутина пыталась отправить. Эта отправляющая горутина снова разблокируется и возобновляется в рабочем состоянии. Горутина **R** продолжает выполнение. В этом случае операция получения из канала также называется **неблокирующей (non-blocking operation)**.

3. Если и очередь буфера значений (**VBQ**), и очередь горутин для отправки канала (**SGQ**) **пусты**, горутина **R** будет помещена в очередь горутин для получения канала и войдет в блокированное состояние. Она может быть возобновлена, когда другая горутина отправит значение в канал. В этом случае операция получения из канала называется **блокирующей (blocking operation)**.

### Операция с каналом — случай *B*

<u> Когда горутина **S** пытается **отправить** значение в не закрытый и не nil-канал </u>, она сначала захватывает блокировку, связанную с каналом, а затем выполняет следующие шаги, пока одно из условий не будет выполнено:

1. Если очередь горутин для получения канала (**RGQ**) **не пуста** (в этом случае очередь буфера значений канала (**VBQ**) должна быть **пуста**), горутина **S** сдвигает горутину из очереди получателей (**RGQ**) и отправляет ей значение. Эта горутина разблокируется и возобновит выполнение. Горутина **S** продолжает выполнение.
➝ В этом случае операция отправки в канал называется **неблокирующей**.

2. Если очередь горутин для получения (**RGQ**) **пуста**, но очередь буфера значений (**VBQ**) **не заполнена** (в этом случае очередь горутин для отправки (**SGQ**) также должна быть **пуста**), то значение, которое горутина **S** пытается отправить, добавляется в буфер канала, и **S** продолжает выполнение.
➝ В этом случае операция отправки в канал также называется **неблокирующей**.

3. Если очередь горутин для получения (**RGQ**) **пуста** и очередь буфера значений уже заполнена, горутина **S** будет помещена в очередь горутин для отправки и войдет в блокированное состояние. Она может возобновить выполнение, когда другая горутина получит значение из канала.
➝ В этом случае операция отправки называется **блокирующей**.

Как уже упоминалось выше, как только не nil-канал закрывается, отправка значения в канал вызовет панику во время выполнения в текущей горутине. Обратите внимание, что отправка данных в закрытый канал рассматривается как **неблокирующая операция**.

### Операция с каналом — случай *C*

<u> Когда горутина пытается закрыть канал, который не является закрытым и не nil </u>, она сначала захватывает блокировку, связанную с каналом, а затем выполняет два шага в следующем порядке:

1. Если очередь горутин для получения (**RGQ**) **не пуста** (в этом случае буфер значений канала (**VBQ**) должен быть **пуст**), каждая горутина из этой очереди будет сдвинута по одной, **получит нулевое значение (zero value)** элемента канала и будет возобновлена.

2. Если очередь горутин для отправки (**SGQ**) **не пуста**, каждая горутина из этой очереди будет сдвинута по одной и вызовет панику (panic), так как отправка данных в закрытый канал запрещена.
→ Это основная причина, по которой нельзя закрывать канал и отправлять в него данные одновременно из нескольких горутин.

Важно! Если [в Go включен детектор состояния гонки](https://golang.org/doc/articles/race_detector.html) (go run -race), то случаи одновременной отправки и закрытия канала могут быть обнаружены во время выполнения, и будет вызвано паническое завершение.

Примечание: После закрытия канала все значения, которые уже были добавлены в его буфер, останутся там и могут быть получены. Подробности об этом в случае *D*.

### Операция с каналом — случай *D*
<u> После закрытия ненулевого канала операции получения данных из канала никогда не блокируются </u>.

- Значения, находящиеся в буфере значений канала (**VBQ**), могут быть получены.
- Второе возвращаемое булево значение остаётся `true`, пока в буфере есть данные.
- Как только все значения в буфере будут получены, все последующие операции получения будут возвращать **нулевые значения (zero values)** типа элементов канала.
- Во всех таких случаях второе возвращаемое булево значение будет `false`, указывая, что полученное значение было получено после закрытия канала.

Знание того, какие операции отправки и получения данных являются блокирующими и неблокирующими, важно для понимания механизма конструкции `select`, которая будет рассмотрена в следующем разделе.

В приведённых выше объяснениях, если горутина удаляется из очереди (очереди отправляющих (**SBQ**) или получающих горутин (**RBQ**)) канала, и эта горутина была заблокирована при помещении в очередь в конструкции `select`, то она возобновит выполнение на шаге 9 выполнения блока `select`. Она может быть удалена из соответствующей очереди горутин нескольких каналов, участвующих в конструкции select.

Факты о внутренних очередях канала
Исходя из приведённых объяснений, можно выделить несколько фактов:

Если канал закрыт, то обе его очереди горутин (отправляющих и получающих) обязательно пусты, но буфер значений может быть не пуст.
В любой момент, если буфер значений не пуст, то очередь получающих горутин обязательно пуста.
В любой момент, если буфер значений не полон, то очередь отправляющих горутин обязательно пуста.
Если канал является буферизированным, то в любой момент хотя бы одна из его очередей горутин (отправляющих или получающих) обязательно пуста.
Если канал является небуферизированным, то в большинстве случаев одна из его очередей горутин (отправляющих или получающих) обязательно пуста, за исключением одного случая: горутина может быть добавлена в обе очереди при выполнении конструкции select.