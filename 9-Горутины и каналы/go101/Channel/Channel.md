# Channels in Go

[Статья](https://go101.org/article/channel.html)

Каналы — это один из ключевых встроенных механизмов в Go, делающий его уникальным. В сочетании с горутинами (goroutine) каналы (channel) значительно упрощают работу с конкурентным программированием (concurrent programming), делая его удобным и даже увлекательным.

Канал в основном выступает в качестве метода [синхронизации конкурентности](https://go101.org/article/control-flows-more.html#synchronization). В этой статье будут перечислены все концепции, синтаксис и правила, связанные с каналом. Чтобы лучше понять каналы, также просто описывается внутренняя структура каналов и некоторые детали реализации стандартным компилятором/средой выполнения Go.

Информация в этой статье может быть немного сложной для новых сусликов. Некоторые части этой статьи, возможно, придется прочитать несколько раз, чтобы полностью понять.

## Введение в каналы (Channel Introduction)

Одно из предложений (сделанное *Робом Пайком*) по конкурентному программированию звучит так:
> **"Не (позволяйте вычислениям) обмениваться данными, совместно используя память, (позвольте им) совместно использовать память, обмениваясь данными (по каналам)."**  
> *("Don't (let computations) communicate by sharing memory, (let them) share memory by communicating (through channels)")*

(В контексте Go каждое вычисление можно рассматривать как горутину.)

**Использование общей памяти для обмена данными** и **обмен данными для совместного использования памяти** — это два разных подхода к конкурентному программированию. Когда горутины обмениваются данными через общую память, применяются традиционные методы синхронизации, такие как мьютексы, для защиты общей памяти и предотвращения гонки данных. Однако можно использовать каналы, чтобы реализовать второй подход — обмен данными для совместного использования памяти.

Go предоставляет уникальный механизм синхронизации — **каналы (channel)**. Каналы позволяют горутинам совместно использовать память через обмен данными. Канал можно представить как внутреннюю очередь **FIFO (первым пришел — первым вышел)** внутри программы. Одни горутины отправляют в канал значения, а другие получают их.

Помимо передачи самих значений через каналы, между горутинами может передаваться и владение этими значениями. Когда горутина отправляет значение в канал, можно рассматривать это как освобождение ею владения значением (которое могло быть доступно через переданное значение). Соответственно, когда другая горутина получает это значение из канала, можно рассматривать это как приобретение владения значением.

Разумеется, не во всех случаях передача данных через канал означает передачу владения. Значения, владение которыми передается, часто (но не обязательно) представляют собой ссылки. Важно понимать, что речь идет о логическом владении. Каналы в Go помогают писать код без гонки данных, но не предотвращают возможность написания неэффективного или некорректного конкурентного кода.

**Хотя Go поддерживает и традиционные методы синхронизации, только каналы являются полноценным элементом языка.** Каналы — это отдельный тип данных в Go, поэтому их можно использовать без подключения дополнительных пакетов. В то же время традиционные механизмы синхронизации реализованы в стандартных пакетах `sync` и `sync/atomic`.

Каждый механизм синхронизации лучше всего подходит для определенных сценариев. Однако каналы обладают широкими возможностями применения и большим разнообразием способов использования. Одна из проблем каналов в том, что программирование с их использованием настолько удобное и приятное, что разработчики могут применять их даже там, где они не являются наилучшим решением.

## Типы и значения каналов

Как и массивы, срезы и отображения (map), каждый тип канала имеет тип элементов. Канал может передавать только значения этого типа.

Каналы бывают двунаправленными и однонаправленными. Пусть `T` — произвольный тип:

1. `chan T` обозначает двунаправленный канал. Компилятор разрешает и отправку, и получение значений из таких каналов.
2. `chan<- T` обозначает канал только для отправки (send-only). Компилятор не позволяет получать значения из таких каналов.
3. `<-chan T` обозначает канал только для получения (receive-only). Компилятор не позволяет отправлять в него значения.

`T` называется типом элементов этих каналов.

Значения двунаправленного типа `chan T` могут неявно преобразовываться как в `chan<- T`, так и в `<-chan T`, но обратное преобразование невозможно, даже явно. Значения типа `chan<- T` нельзя преобразовать в `<-chan T` и наоборот.
Следует отметить, что `<-` в объявлениях типов каналов является модификатором, а не оператором.

Каждое значение канала имеет емкость (capacity), которая будет рассмотрена в следующем разделе.

* Канал с емкостью 0 называется небуферизованным (unbuffered).
* Канал с емкостью больше 0 называется буферизованным (buffered).

Значения по умолчанию (zero values) для типов каналов представлены предопределенным идентификатором nil.
Чтобы создать не nil канал, необходимо использовать встроенную функцию make.

Пример:
```go
make(chan int, 10)
```

Этот вызов создаст канал с типом элементов int и емкостью 10.

Второй аргумент в make задает емкость канала. Он необязательный; если его не указать, емкость будет равна 0.

## Сравнение значений каналов

Все типы каналов в Go являются сравнимыми (comparable).

Из статьи [value parts](https://go101.org/article/value-part.html) мы знаем, что значения канала, отличные от nil, являются значениями, состоящими из нескольких частей. Если одно значение канала присваивается другому, то оба канала используют одну и ту же базовую часть. Другими словами, эти два канала представляют один и тот же объект внутреннего канала. Результатом их сравнения является `true`.

## Операции с каналами
В Go определено пять операций для работы с каналами. Пусть `ch` — некоторый канал, тогда:

1. Закройте канал, используя следующий вызов функции
	```go
	close(ch)
	```
	где `close` - это встроенная функция. Аргументом вызова функции `close` должно быть значение канала, а канал `ch` не должен быть каналом только для приема (`<-chan T`).

2. Отправьте значение `v` в канал, используя следующий синтаксис
	```go
	ch <- v
	```
	где `v` должно быть значением, которое может быть присвоено типу элемента канала `ch`, и канал `ch` не должен быть каналом только для приема (`<-chan T`). Оператор `<-` здесь — **оператор отправки**.

3. Получение значения из канала с помощью следующего синтаксиса

	```go
	<-ch
	```

	Операция получения по каналу всегда возвращает по крайней мере один результат, который является значением типа элемента канала, и канал `ch` не должен быть каналом только для отправки (`chan<- T`). Оператор `<-` в этом случае — **оператор получения**.

	В большинстве случаев получение значения из канала используется как выражение с одним значением:
	```go
	v = <-ch
	```
	Однако, когда операция с каналом используется в качестве единственного исходного значения в присваивании, результатом может быть второе необязательное нетипизированное логическое значение и выражение может быть многозначным.
	
	Однако, если канал закрыт, можно проверить, было ли значение отправлено **до закрытия**:
	```go
	v, sentBeforeClosed = <-ch
	```
	Здесь `sentBeforeClosed` — булево значение, которое равно `false`, если канал был закрыт и больше в нем нет данных.
	(Ниже мы узнаем, что мы можем получать неограниченное количество значений из закрытого канала.)

4. Получение емкости канала
	```go
	cap(ch)
	```
	где `cap` - это встроенная функция, которая когда-либо была представлена в [контейнерах в Go](https://go101.org/article/container.html#cap-len). Результатом вызова функции `cap` является значение `int`.
5. Получение текущей длины канала
   	```go
   	len(ch)
	```
	где `len` - это встроенная функция, которая также когда-либо использовалась ранее. Возвращаемое значение при вызове функции `len` - это значение типа `int`. Результирующая длина - это количество элементов, которые уже были успешно отправлены в запрошенный канал, но еще не были получены (извлечены).

Большинство базовых операций в Go не являются синхронизированными. Другими словами, они не являются потокобезопасными ( они не являются безопасными с точки зрения конкурентности). К таким операциям относятся
- присваивание значений,
- передача аргументов,
- манипуляции с элементами контейнеров и т. д.
Однако все представленные операции с каналами уже синхронизированы, поэтому дополнительная синхронизация не требуется для безопасного выполнения этих операций.

Как и большинство других операций в Go, присваивание значений каналов не является синхронизированным. Аналогично, присваивание полученного из канала значения другой переменной также не является синхронизированным, хотя сама операция получения значения из канала синхронизирована.

Если проверяемый канал является `nil`-каналом, то встроенные функции `cap` и `len` вернут ноль. Эти две операции настолько просты, что не будут подробно рассматриваться позже. Фактически, на практике они используются редко.

Операции отправки, получения и закрытия каналов будут подробно рассмотрены в следующем разделе.

## Подробные объяснения операций с каналами

Чтобы сделать объяснения операций с каналами простыми и понятными, в оставшейся части статьи каналы будут разделены на три категории:

1. `nil`-каналы.
2. Не `nil`, но закрытые (closed) каналы.
3. Не закрытые не `nil`-каналы.

В следующей таблице кратко суммированы поведения всех видов операций, применяемых к `nil`, закрытым и не закрытым не `nil`-каналам.

| Операция           | `nil`-канал   | закрытый канал | не закрытый не `nil`-канал |
|--------------------|--------------|---------------|----------------------------|
| `close(ch)`        | panic        | panic        | succeed to close (*C*)          |
| send `ch <- v`     | block forever | panic        | block or succeed to send (*B*)  |
| receive `v <- ch`  | block forever | never block (*D*)  | block or succeed to receive (*A*) |

Для пяти случаев, показанных без индексов, поведение каналов очевидно:

1. Закрытие `nil`-канала или уже закрытого канала вызывает панику в текущей горутине.
2. Отправка значения в закрытый канал также вызывает панику в текущей горутине.
3. Отправка значения в `nil`-канал или получение значения из `nil`-канала приводит к вечной блокировке текущей горутины.

Далее будут даны дополнительные объяснения для четырех случаев, помеченных индексами (*A*, *B*, *C* и *D*).

Чтобы лучше понять типы и значения каналов, а также упростить объяснение некоторых аспектов их работы, полезно рассмотреть их внутренние структуры.

Мы можем представить каждый канал как состоящий из трех очередей (все они могут быть рассмотрены как FIFO-очереди) на внутреннем уровне:

1. **receiving goroutine queue (RGQ)** Очередь горутин для получения (обычно FIFO). Эта очередь представляет собой связанный список без ограничения по размеру. Горутинки в этой очереди находятся в заблокированном состоянии и ожидают получения значений из канала.

2. **sending goroutine queue (SGQ)** Очередь горутин для отправки (обычно FIFO). Эта очередь также представляет собой связанный список без ограничения по размеру. Горутинки в этой очереди находятся в заблокированном состоянии и ожидают отправки значений в канал. Значение (или адрес значения, в зависимости от реализации компилятора), которое каждая горутина пытается отправить, также хранится в очереди вместе с этой горутиной.

3. **value buffer queue (VBQ)** Очередь буфера значений (абсолютно FIFO). Это кольцевая очередь. Ее размер равен емкости канала. Типы значений, хранящихся в этой очереди, соответствуют элементам типа канала. Если текущее количество значений в буфере значений канала достигает емкости канала, канал считается "полным". Если в буфере нет значений, канал считается "пустым". Для канала с нулевой емкостью (небуферизованный) он всегда находится и в состоянии полного, и в состоянии пустого.

Каждый канал внутренне содержит мьютекс для предотвращения гонок данных при выполнении различных операций.

### Операция с каналом — случай *A*
<u> Когда горутина **R** пытается **получить** значение из не закрытого и не nil-канала </u>, горутина **R** получает блокировку, связанную с каналом, а затем выполняет следующие шаги до тех пор, пока одно из условий не будет выполнено:

1. Если очередь буфера значений канала (**VBQ**) **не пуста** (в этом случае очередь горутин для получения канала (**RGQ**) должна быть **пуста**), горутина **R** получает (сдвигает) значение из буфера значений канала. Если очередь горутин для отправки канала (**SGQ**) также не пуста, то из нее сдвигается горутина, и она возобновляется в рабочем состоянии. Значение, которое эта отправляющая горутина пыталась отправить, будет помещено в очередь буфера значений канала (**VBQ**). После этого горутина **R** продолжает выполнение. В этом случае операция получения из канала называется **неблокирующей (non-blocking operation)**.

2. Если очередь буфера значений (**VBQ**) **пуста**, и если очередь горутин для отправки канала (**SGQ**) **не пуста** (в этом случае канал должен быть небуферизированным), горутина **R** сдвигает отправляющую горутину из очереди горутин для отправки канала и получает значение, которое эта отправляющая горутина пыталась отправить. Эта отправляющая горутина снова разблокируется и возобновляется в рабочем состоянии. Горутина **R** продолжает выполнение. В этом случае операция получения из канала также называется **неблокирующей (non-blocking operation)**.

3. Если и очередь буфера значений (**VBQ**), и очередь горутин для отправки канала (**SGQ**) **пусты**, горутина **R** будет помещена в очередь горутин для получения канала и войдет в блокированное состояние. Она может быть возобновлена, когда другая горутина отправит значение в канал. В этом случае операция получения из канала называется **блокирующей (blocking operation)**.

### Операция с каналом — случай *B*

<u> Когда горутина **S** пытается **отправить** значение в не закрытый и не nil-канал </u>, она сначала захватывает блокировку, связанную с каналом, а затем выполняет следующие шаги, пока одно из условий не будет выполнено:

1. Если очередь горутин для получения канала (**RGQ**) **не пуста** (в этом случае очередь буфера значений канала (**VBQ**) должна быть **пуста**), горутина **S** сдвигает горутину из очереди получателей (**RGQ**) и отправляет ей значение. Эта горутина разблокируется и возобновит выполнение. Горутина **S** продолжает выполнение.
➝ В этом случае операция отправки в канал называется **неблокирующей**.

2. Если очередь горутин для получения (**RGQ**) **пуста**, но очередь буфера значений (**VBQ**) **не заполнена** (в этом случае очередь горутин для отправки (**SGQ**) также должна быть **пуста**), то значение, которое горутина **S** пытается отправить, добавляется в буфер канала, и **S** продолжает выполнение.
➝ В этом случае операция отправки в канал также называется **неблокирующей**.

3. Если очередь горутин для получения (**RGQ**) **пуста** и очередь буфера значений уже заполнена, горутина **S** будет помещена в очередь горутин для отправки и войдет в блокированное состояние. Она может возобновить выполнение, когда другая горутина получит значение из канала.
➝ В этом случае операция отправки называется **блокирующей**.

Как уже упоминалось выше, как только не nil-канал закрывается, отправка значения в канал вызовет панику во время выполнения в текущей горутине. Обратите внимание, что отправка данных в закрытый канал рассматривается как **неблокирующая операция**.

### Операция с каналом — случай *C*

<u> Когда горутина пытается закрыть канал, который не является закрытым и не nil </u>, она сначала захватывает блокировку, связанную с каналом, а затем выполняет два шага в следующем порядке:

1. Если очередь горутин для получения (**RGQ**) **не пуста** (в этом случае буфер значений канала (**VBQ**) должен быть **пуст**), каждая горутина из этой очереди будет сдвинута по одной, **получит нулевое значение (zero value)** элемента канала и будет возобновлена.

2. Если очередь горутин для отправки (**SGQ**) **не пуста**, каждая горутина из этой очереди будет сдвинута по одной и вызовет панику (panic), так как отправка данных в закрытый канал запрещена.
→ Это основная причина, по которой нельзя закрывать канал и отправлять в него данные одновременно из нескольких горутин.

Важно! Если [в Go включен детектор состояния гонки](https://golang.org/doc/articles/race_detector.html) (go run -race), то случаи одновременной отправки и закрытия канала могут быть обнаружены во время выполнения, и будет вызвано паническое завершение.

Примечание: После закрытия канала все значения, которые уже были добавлены в его буфер, останутся там и могут быть получены. Подробности об этом в случае *D*.

### Операция с каналом — случай *D*
<u> После закрытия ненулевого канала операции получения данных из канала никогда не блокируются </u>.

- Значения, находящиеся в буфере значений канала (**VBQ**), могут быть получены.
- Второе возвращаемое булево значение остаётся `true`, пока в буфере есть данные.
- Как только все значения в буфере будут получены, все последующие операции получения будут возвращать **нулевые значения (zero values)** типа элементов канала.
- Во всех таких случаях второе возвращаемое булево значение будет `false`, указывая, что полученное значение было получено после закрытия канала.

Знание того, какие операции отправки и получения данных являются блокирующими и неблокирующими, важно для понимания механизма конструкции `select`, которая будет рассмотрена в следующем разделе.

В приведённых выше объяснениях, если горутина удаляется из очереди канала (очереди отправляющих (**SBQ**) или получающих горутин (**RBQ**)), и эта горутина была заблокирована при помещении в очередь в конструкции `select`, то она возобновит выполнение на шаге 9 выполнения блока `select`. Она может быть удалена из соответствующей очереди горутин нескольких каналов, участвующих в конструкции `select`.

🔹 Разбор по шагам:

1. Горутина блокируется внутри `select`, потому что все возможные операции на каналах в этом `select` не могут быть немедленно выполнены (например, канал пуст или переполнен).
2. Горутина помещается в очередь соответствующего канала (отправляющую или получающую).
3. Когда в каком-либо канале из `select` появляется возможность выполнить операцию (например, другой поток отправил или получил данные), горутина извлекается из очереди этого канала.
4. Она возобновляет выполнение на этапе 9 выполнения `select`.
5. Если `select` включал несколько каналов, горутина могла находиться сразу в нескольких очередях каналов. В таком случае она будет удалена из всех очередей, но выполнится только одна из возможных операций (та, которая стала доступной первой).

Согласно перечисленным выше пояснениям, мы можем получить некоторые факты о внутренних очередях канала.

1. **Если канал закрыт**, то обе его очереди горутин (отправляющих (**SGQ**) и получающих (**RGQ**)) **обязательно пусты**, но буфер значений **может быть** (**VBQ**) **не пуст**.
2. В любой момент, если буфер значений (**VBQ**) **не пуст**, то очередь получающих горутин (**RGQ**) обязательно **пуста**.
3. В любой момент, если буфер значений (**VBQ**) **не полон**, то очередь отправляющих горутин (**SGQ**) **обязательно пуста**.
4. Если канал является буферизированным, то в любой момент хотя бы одна из его очередей горутин (отправляющих **SGQ**) или получающих (**RGQ**)) **обязательно пуста**.
5. Если канал является небуферизированным, то в большинстве случаев одна из его очередей горутин (отправляющих **SGQ**) или получающих (**RGQ**)) **обязательно пуста**, за исключением одного случая: горутина может быть добавлена в обе очереди при выполнении конструкции `select`.

## Некоторые примеры использования каналов

Теперь, когда вы прочитали предыдущий раздел, давайте рассмотрим несколько примеров, в которых используются каналы, чтобы улучшить ваше понимание.

Простой пример запроса/ответа (request/response). Две программы в этом примере взаимодействуют друг с другом через небуферизованный канал.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int) // an unbuffered channel
	go func(ch chan<- int, x int) {
		time.Sleep(time.Second)
		// <-ch    // fails to compile
		// Send the value and block until the result is received.
		ch <- x*x // 9 is sent
	}(c, 3)
	done := make(chan struct{})
	go func(ch <-chan int) {
		// Block until 9 is received.
		n := <-ch
		fmt.Println(n) // 9
		// ch <- 123   // fails to compile
		time.Sleep(time.Second)
		done <- struct{}{}
	}(c)
	// Block here until a value is received by
	// the channel "done".
	<-done
	fmt.Println("bye")
}
```

Вывод:
```go
9
bye
```

Демонстрация использования буферизованного канала. Эта программа не является конкурентной, она просто показывает, как использовать буферизованные каналы.

```go
package main

import "fmt"

func main() {
	c := make(chan int, 2) // a buffered channel
	c <- 3
	c <- 5
	close(c)
	fmt.Println(len(c), cap(c)) // 2 2
	x, ok := <-c
	fmt.Println(x, ok) // 3 true
	fmt.Println(len(c), cap(c)) // 1 2
	x, ok = <-c
	fmt.Println(x, ok) // 5 true
	fmt.Println(len(c), cap(c)) // 0 2
	x, ok = <-c
	fmt.Println(x, ok) // 0 false
	x, ok = <-c
	fmt.Println(x, ok) // 0 false
	fmt.Println(len(c), cap(c)) // 0 2
	close(c) // panic!
	// The send will also panic if the above
	// close call is removed.
	c <- 7
}
```

Бесконечный футбольный матч.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	var ball = make(chan string)
	kickBall := func(playerName string) {
		for {
			fmt.Println(<-ball, "kicked the ball.")
			time.Sleep(time.Second)
			ball <- playerName
		}
	}
	go kickBall("John")
	go kickBall("Alice")
	go kickBall("Bob")
	go kickBall("Emily")
	ball <- "referee" // kick off
	var c chan bool   // nil
	<-c               // blocking here for ever
}
```

Пожалуйста, ознакомьтесь [с примерами использования каналов](https://go101.org/article/channel-use-cases.html), чтобы узнать больше о них.

## Значения элементов канала передаются через копирование

Когда значение передаётся из одной горутины в другую, оно **будет скопировано как минимум один раз**. Если переданное значение остаётся в буфере канала, то в процессе передачи произойдёт два копирования. Первое копирование происходит, когда значение записывается из отправляющей горутины в буфер канала, а второе — когда оно копируется из буфера канала в принимающую горутину.

Как и при присваивании значений или передаче аргументов в функции, при передаче значения [копируется только его непосредственная часть](https://go101.org/article/value-part.html#about-value-copy).

В стандартном компиляторе Go размер элементов канала должен быть меньше **65536** байт. Однако, как правило, не следует создавать каналы с крупными элементами, чтобы избежать высокой стоимости копирования при передаче значений между горутинами. Если передаваемые значения слишком велики, лучше использовать указатели в качестве типа элементов канала, чтобы избежать избыточного копирования.

## Сборка мусора каналов и горутин
**Канал не может быть удалён сборщиком мусора, если хотя бы одна из его очередей (отправки или получения) не пуста, потому что в этом случае на него остаются ссылки от горутин, ожидающих отправки или получения данных.**

То есть пока есть заблокированные горутины, ожидающие операции с каналом, сам канал остаётся достижимым и не подлежит сборке мусора.

Если горутина заблокирована в ожидании отправки или получения данных через канал, она не может быть удалена сборщиком мусора, даже если больше нет других ссылок на канал, кроме самой этой горутины. Это происходит потому, что заблокированная горутина остаётся в очереди канала, и пока она там находится, она считается активной и не подлежит удалению.

**Горутина может быть собрана сборщиком мусора только после её завершения, когда она полностью выходит из выполнения и больше не ссылается ни на какие объекты.**

## Операции отправки и получения канала являются простыми инструкциями

Операции отправки и получения по каналу являются [простыми инструкциями](https://go101.org/article/expressions-and-statements.html#simple-statements). Операция получения из канала всегда может использоваться как однозначное выражение. Простые операторы и выражения могут использоваться в определенных частях [основных блоков потока управления](https://go101.org/article/control-flows.html).

Пример, в котором операции отправки и получения по каналу отображаются в виде простых инструкций в двух блоках потока управления `for`.

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fibonacci := func() chan uint64 {
		c := make(chan uint64)
		go func() {
			var x, y uint64 = 0, 1
			for ; y < (1 << 63); c <- y { // here
				x, y = y, x+y
			}
			close(c)
		}()
		return c
	}
	c := fibonacci()
	for x, ok := <-c; ok; x, ok = <-c { // here
		time.Sleep(time.Second)
		fmt.Println(x)
	}
}
```

## `for-range` по  каналам

Блок кода потока управления `for-range` применяется к каналам. Цикл будет пытаться итеративно получать значения, отправленные в канал, до тех пор, пока канал не будет закрыт и его очередь в буфере значений не станет пустой. Синтаксис `for-range` для массивов, срезов и отображений допускает несколько итерационных переменных. Однако для блоков `for-range`, применяемых к каналам, вы можете использовать **не более одной итерационной переменной**, которая используется для хранения полученных значений.

```go
for v := range aChannel {
	// use v
}
```
или эквивалент
```go
for {
	v, ok = <-aChannel
	if !ok {
		break
	}
	// use v
}
```

Конечно, здесь `aChannel` не должен быть каналом только для отправки (`chan<-`). Если это nil-канал, цикл будет заблокирован навсегда.

Например, второй блок цикла `for` в примере, показанном в предыдущем разделе, может быть упрощен до

```go
for x := range c {
		time.Sleep(time.Second)
		fmt.Println(x)
	}
```

## `select-case` Блоки кода потока управления

Существует синтаксис блока `select-case`, который специально разработан для работы с каналами. Этот синтаксис во многом похож на `switch-case`. Например, в блоке `select-case` может быть несколько веток `case` и не более одной ветки `default`. Однако между ними есть и очевидные различия:

- После ключевого слова select (перед `{`) не допускаются выражения и операторы.
- В ветках `case` нельзя использовать оператор `fallthrough`.
- Каждое выражение после ключевого слова `case` в блоке `select-case` должно быть либо операцией приёма из канала (`<-ch`), либо операцией отправки в канал (`ch<-`).
Операция приёма может использоваться как источник значения в простом операторе присваивания. В дальнейшем операция с каналом, следующая за `case`, будет называться `case` операцией.
- Если в блоке `select-case` есть одна или несколько неблокирующих операций `case`, среда выполнения Go случайным образом выберет одну из таких операций для выполнения, а затем продолжит выполнение соответствующей ветки `case`.
- Если все операции `case` в блоке `select-case` являются блокирующими, то, при наличии ветки `default`, будет выполнена именно она. Если ветка `default` отсутствует, то текущая горутина будет помещена в очередь отправляющих или принимающих горутин для каждого канала, участвующего в операциях case, и перейдёт в состояние блокировки.

Согласно этим правилам, пустой `select` без каких-либо веток (`select{}`) приведёт к бесконечной блокировке текущей горутины.

Следующая программа гарантированно выполнит ветку `default`.

```go
package main

import "fmt"

func main() {
	var c chan struct{} // nil
	select {
	case <-c:             // blocking operation
	case c <- struct{}{}: // blocking operation
	default:
		fmt.Println("Go here.")
	}
}
```

Пример, показывающий, как использовать `try-send` и `try-receive`:

```go
package main

import "fmt"

func main() {
	c := make(chan string, 2)
	trySend := func(v string) {
		select {
		case c <- v:
		default: // go here if c is full.
		}
	}
	tryReceive := func() string {
		select {
		case v := <-c: return v
		default: return "-" // go here if c is empty
		}
	}
	trySend("Hello!") // succeed to send
	trySend("Hi!")    // succeed to send
	// Fail to send, but will not block.
	trySend("Bye!")
	// The following two lines will
	// both succeed to receive.
	fmt.Println(tryReceive()) // Hello!
	fmt.Println(tryReceive()) // Hi!
	// The following line fails to receive.
	fmt.Println(tryReceive()) // -
}
```

В следующем примере вероятность возникновения паники составляет 50%. В этом примере обе операции `case` не являются блокирующими.

```go
package main

func main() {
	c := make(chan struct{})
	close(c)
	select {
	case c <- struct{}{}:
		// Panic if the first case is selected.
	case <-c:
	}
}
```

## Реализация механизма `select` в Go

Механизм `select` в Go — это важная и уникальная особенность. Ниже перечислены шаги е[го реализации в официальном Go-рантайме](https://github.com/golang/go/blob/master/src/runtime/select.go).

Шаги выполнения блока `select-case`

1. **Оценка выражений**

	- Все выражения каналов и значений, которые потенциально могут участвовать в операциях `case`, вычисляются сверху вниз и слева направо.
	- Значения назначения для операций чтения (receive operations) в операциях присваивания не обязаны быть вычислены на этом этапе.

2. **Перемешивание порядка веток**
	Порядок веток `case` перемешивается для дальнейшей обработки на шаге 5.

	- Ветка `default` всегда ставится на последнее место в итоговом порядке.
	- В операциях `case` могут встречаться повторяющиеся каналы.

3. **Сортировка каналов**
	Все задействованные в `case` каналы сортируются, чтобы избежать взаимоблокировок (deadlock) с другими горутинами на следующем шаге.

	- В первые **N** каналов отсортированного списка не должны попадать повторяющиеся каналы, где `N` — это число каналов в операциях `case`.
	- Этот порядок называется порядком блокировки каналов (**channel lock order**).
	- 

4. **Блокировка всех задействованных каналов**
	Захватываются блокировки всех каналов согласно порядку, установленному на предыдущем шаге.

5. **Опрос веток `case` в перемешанном порядке**

	1. Если это ветка `case`, и операция отправки значения производится в закрытый канал —
      	- Разблокировать все каналы в порядке, обратном порядку блокировки.
      	- Вызвать `panic` у текущей горутины.
      	- Перейти к шагу 12.
	2. Если это ветка `case`, и операция отправки/чтения из канала не блокирует выполнение —
		- Выполнить операцию над каналом.
		- Разблокировать все каналы в порядке, обратном порядку блокировки.
		- Выполнить тело соответствующей ветки case.
		- Возможно, пробудить другую горутину из состояния блокировки.
		- Перейти к шагу 12.
	3. Если это ветка default —
		- Разблокировать все каналы в порядке, обратном порядку блокировки.
		- Выполнить тело ветки `default`.
		- Перейти к шагу 12.
	
	(**К этому моменту ветка `default` отсутствует, а все case-операции оказываются блокирующими.**)

6. **Добавление горутины в очередь**
	Текущая горутина (вместе с информацией о соответствующей ветке `case`) ставится в очередь на получение или отправку данных для соответствующих каналов.

	- Горутина может попасть в очередь одного и того же канала несколько раз, если он задействован в нескольких `case`.

7. **Перевод горутины в состояние блокировки**
	Горутина переводится в режим ожидания, и все каналы разблокируются в порядке, обратном порядку блокировки.

8. **Ожидание разблокировки**
	Горутина остается в заблокированном состоянии, пока не будет разбужена другой операцией над каналом.

9. **Пробуждение горутины**
	Горутина пробуждается другой операцией с каналом, выполненной в другой горутине.

	- Это может быть закрытие канала (`close`) или операция отправки/чтения.
	- Если это операция отправки/чтения, то в `select-case` должен присутствовать `case`, который может с ней взаимодействовать (например, принять переданное значение).
	- В процессе взаимодействия горутина удаляется из очереди ожидания канала.

10. **Повторная блокировка всех задействованных каналов**
	Блокировки всех каналов снова захватываются в установленном ранее порядке.

11. Удаление горутины из очереди ожидания и выполнение case

	- Если горутина была пробуждена операцией закрытия канала — перейти к шагу 5.
	- Если горутина была пробуждена операцией отправки/чтения —
		- Разблокировать все каналы в порядке, обратном порядку блокировки.
		- Выполнить тело соответствующей ветки case.
12. **Завершение выполнения**

Из реализации видно, что:

1. Горутина может одновременно находиться в очередях отправки и получения данных у нескольких каналов. Более того, она может находиться как в очереди отправки, так и в очереди получения данных одного и того же канала одновременно.
2. Когда горутина, заблокированная на `select-case`, возобновляет выполнение, она удаляется из всех очередей отправки и получения данных во всех каналах, участвующих в операциях `case` в данном блоке `select-case`.

### Дополнительно
[В этой статье](https://go101.org/article/channel-use-cases.html) можно найти больше примеров использования каналов.

Хотя каналы помогают писать [корректный конкурентный код](https://go101.org/article/channel-use-cases.html), как и другие методы синхронизации данных, они не защищают от [неправильного использования](https://go101.org/article/channel-use-cases.html).

Каналы не всегда являются наилучшим решением для всех случаев синхронизации данных. Ознакомьтесь [с этой статьей](https://go101.org/article/concurrent-synchronization-more.html) и [этой статьей](https://go101.org/article/concurrent-atomic-operation.html), чтобы узнать о других техниках синхронизации в Go.