# Как изящно закрыть каналы

[Статья](https://go101.org/article/channel-closing.html)


Несколько дней назад я написал статью, в которой объясняются [правила работы с каналами в Go](https://go101.org/article/channel.html). Эта статья получила много голосов на [Reddit](https://www.reddit.com/r/golang/comments/5k489v/the_full_list_of_channel_rules_in_golang/) и [HN](https://news.ycombinator.com/item?id=13252416), но также вызвала некоторые критические замечания относительно деталей дизайна каналов в Go.

Я собрал несколько распространённых критических замечаний о следующих аспектах каналов в Go:

1. Нет простого и универсального способа проверить, закрыт ли канал, без изменения его состояния.
2. Закрытие уже закрытого канала вызовет панику, поэтому опасно закрывать канал, если вызывающий не уверен в его статусе.
3. Отправка значений в закрытый канал вызовет панику, поэтому опасно отправлять данные в канал, если отправитель не знает, закрыт он или нет.

Эти замечания кажутся обоснованными, но на самом деле это не так. Действительно, в Go нет встроенной функции для проверки, закрыт ли канал.

Однако существует простой метод, позволяющий проверить, закрыт ли канал, при условии, что в него не отправлялись (и не будут отправляться) значения. Этот метод уже был показан в [предыдущей статье](https://go101.org/article/channel-use-cases.html#check-closed-status). Для удобства он приведён в следующем примере.

```go
package main

import "fmt"

type T int

func IsClosed(ch <-chan T) bool {
	select {
	case <-ch:
		return true
	default:
	}

	return false
}

func main() {
	c := make(chan T)
	fmt.Println(IsClosed(c)) // false
	close(c)
	fmt.Println(IsClosed(c)) // true
}
```

Как упомянуто выше, это не универсальный способ проверки, закрыт ли канал.

Фактически, даже если бы в Go существовала встроенная функция `closed`, позволяющая проверять, закрыт ли канал, её полезность была бы очень ограниченной. Это похоже на встроенную функцию `len`, которая показывает количество элементов в буфере канала. Проблема в том, что состояние канала может измениться сразу после вызова такой функции, и возвращённое значение уже не будет актуальным.

Хотя допустимо прекратить отправку данных в канал `ch`, если `closed(ch)` возвращает `true`, нельзя безопасно продолжать отправку данных или закрывать канал, если `closed(ch)` возвращает `false`.

## Принцип закрытия каналов

Общий принцип работы с каналами в Go: **не закрывайте канал на стороне получателя и не закрывайте канал, если у него несколько отправителей**. Иными словами, закрывать **канал должна только та горутина, которая отправляет данные**, и только если **она является единственным отправителем**.

(Далее этот принцип будем называть **принципом закрытия каналов** - **channel closing principle**)

Разумеется, это не единственный возможный подход. Универсальный принцип: **не закрывать (и не отправлять значения в) закрытые каналы**. Если можно гарантировать, что ни одна горутина больше не будет закрывать и отправлять данные в не закрытый и не nil-канал, тогда канал можно закрыть безопасно. Однако обеспечение таких гарантий со стороны получателя или одного из нескольких отправителей требует больших усилий и усложняет код. Напротив, придерживаться вышеупомянутого принципа закрытия каналов (**channel closing principle**) намного проще.

## Решения с "грубым" закрытием каналов
Если вам всё же необходимо закрыть канал на стороне получателя или в одной из нескольких горутин-отправителей, можно использовать [механизм recover](https://go101.org/article/control-flows-more.html#panic-recover), чтобы предотвратить панику при закрытии уже закрытого канала.

Пример (предположим, что канал передаёт элементы типа `T`):

```go
func SafeClose(ch chan int) (justClosed bool) {
	defer func() {
		if recover() != nil {
			// Возврат можно изменить в функции defer.
			justClosed = false
		}
	}()

	// предполагаем, что ch != nil здесь.
	close(ch)   // вызовет panic, если канал уже закрыт
	return true // то же самое, что justClosed = true; return
}
```

Это решение, очевидно, нарушает **принцип закрытия каналов**.

Ту же идею можно использовать при отправке значений в потенциально закрытый канал.

```go
func SafeSend(ch chan T, value T) (closed bool) {
	defer func() {
		if recover() != nil {
			closed = true
		}
	}()

	ch <- value  // вызовет panic, если канал уже закрыт
	return false // <=> closed = false; return
}
```

Грубое решение не только нарушает **принцип закрытия каналов**, но и может привести к **гонке данных (data races)** в процессе.

## Решения, которые вежливо (**politely**) закрывают каналы
Многие разработчики предпочитают использовать `sync.Once` для закрытия каналов:

```go
type MyChannel struct {
	C    chan T
	once sync.Once
}

func NewMyChannel() *MyChannel {
	return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
	mc.once.Do(func() {
		close(mc.C)
	})
}
```

Конечно, мы также можем использовать `sync.Mutex`, чтобы избежать многократного закрытия канала:

```go
type MyChannel struct {
	C      chan T
	closed bool
	mutex  sync.Mutex
}

func NewMyChannel() *MyChannel {
	return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()
	if !mc.closed {
		close(mc.C)
		mc.closed = true
	}
}

func (mc *MyChannel) IsClosed() bool {
	mc.mutex.Lock()
	defer mc.mutex.Unlock()
	return mc.closed
}
```

Эти методы **могут быть аккуратными, но они не гарантируют отсутствие гонки данных (data races)**. В текущей спецификации Go **нет гарантии, что при одновременном выполнении операций закрытия канала и отправки данных в канал не возникнет гонки данных**. Если функция `SafeClose` вызывается одновременно с операцией отправки данных в тот же канал, может возникнуть гонка данных (хотя обычно оно не приводит к критическим ошибкам).

## Решения, которые закрывают каналы более элегантно

Один из недостатков функции `SafeSend`, описанной выше, заключается в том, что её вызовы нельзя использовать в качестве операций отправки, следующих за ключевым словом `case` в `select`-блоках. Другой недостаток функций `SafeSend` и `SafeClose` в том, что многие разработчики, включая меня, считают, что использование `panic/recover` и пакета `sync` в этих решениях не является элегантным.

Далее будут представлены решения, основанные только на механизме каналов, без использования `panic/recover` и пакета `sync`, подходящие для различных ситуаций.
(В следующих примерах используется `sync.WaitGroup`, чтобы сделать примеры завершёнными. Однако в реальной практике его использование не всегда обязательно.)

### 1. M получателей, один отправитель, отправитель сообщает "больше не будет отправок", закрывая канал данных

Это самый простой случай — просто позволить отправителю закрыть канал данных, когда он больше не хочет отправлять данные.

```go
package main

import (
	"log"
	"math/rand"
	"sync"
)

func main() {
	log.SetFlags(0)

	// ...
	const Max = 100000       // максимальное значение
	const NumReceivers = 100 // количество получателей

	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)

	// отправитель
	go func() {
		for {
			if value := rand.Intn(Max); value == 0 {
				// Единственный отправитель может
				// безопасно закрыть канал в любой момент.
				close(dataCh)
				return
			} else {
				dataCh <- value
			}
		}
	}()

	// получатели
	for i := 0; i < NumReceivers; i++ {
		go func() {
			defer wgReceivers.Done()

			// Читаем значения, пока канал dataCh не будет
			// закрыт и его буферная очередь не опустеет.
			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	wgReceivers.Wait()
}
```

### Один получатель, N отправителей, единственный получатель сообщает "пожалуйста, прекратите отправку" через закрытие дополнительного сигнального канала

Этот случай немного сложнее предыдущего. Мы не можем позволить получателю закрыть канал данных для прекращения передачи данных, так как это нарушит **принцип закрытия каналов**. Однако мы можем позволить получателю закрыть дополнительный сигнальный канал, чтобы уведомить отправителей о необходимости прекратить отправку данных.

```go
package main

import (
	"log"
	"math/rand"
	"sync"
)

func main() {
	log.SetFlags(0)

	// ...
	const Max = 100000      // максимальное значение
	const NumSenders = 1000 // количество отправителей

	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(1)

	// ...
	dataCh := make(chan int)
	stopCh := make(chan struct{})
	// stopCh — это дополнительный сигнальный канал.
	// Его отправитель — это получатель из dataCh,
	// а его получатели — это все отправители в dataCh.

	// отправители
	for i := 0; i < NumSenders; i++ {
		go func() {
			for {
				// Попытка чтения stopCh, чтобы
				// завершить горутину как можно раньше.
				// В данном примере это не критично.
				select {
				case <-stopCh:
					return
				default:
				}

				// Даже если stopCh закрыт, вторая select
				// может иногда выбирать ветку с отправкой
				// в dataCh, если канал не заблокирован.
				// Это допустимо в этом примере, так что
				// первый select можно было бы и убрать.
				select {
				case <-stopCh:
					return
				case dataCh <- rand.Intn(Max):
				}
			}
		}()
	}

	// получатель
	go func() {
		defer wgReceivers.Done()

		for value := range dataCh {
			if value == Max-1 {
				// Получатель из dataCh также является
				// отправителем в stopCh.
				// Закрыть stopCh здесь безопасно.
				close(stopCh)
				return
			}

			log.Println(value)
		}
	}()

	// ...
	wgReceivers.Wait()
}
```

Как упомянуто в комментариях, для дополнительного сигнального канала его отправителем является получатель данных из основного канала. Дополнительный сигнальный канал закрывается своим единственным отправителем, что соответствует принципу закрытия каналов.

В этом примере канал `dataCh` никогда не закрывается. Да, закрывать каналы вовсе не обязательно. Канал в конечном итоге будет удалён сборщиком мусора, если на него больше нет ссылок в горутинах, независимо от того, закрыт он или нет. Таким образом, в данном случае изящество закрытия канала заключается в том, чтобы вовсе не закрывать его.

### 3. M получателей, N отправителей, любой из них может сказать "давайте закончим игру", уведомив модератора о закрытии дополнительного сигнального канала

Это самая сложная ситуация. Мы **не можем позволить ни одному из получателей или отправителей закрыть канал данных**. Также **мы не можем позволить какому-либо из получателей закрыть дополнительный сигнальный канал для уведомления всех участников о завершении работы**, так как это нарушит **принцип закрытия каналов**. Однако мы можем **ввести роль модератора, который будет отвечать за закрытие сигнального канала**.

Одним из ключевых приёмов в следующем примере является использование попытки отправки (**try-send**), чтобы уведомить модератора о необходимости закрытия дополнительного сигнального канала.

```go
package main

import (
	"log"
	"math/rand"
	"strconv"
	"sync"
)

func main() {
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumReceivers = 10
	const NumSenders = 1000

	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)
	stopCh := make(chan struct{})
	// stopCh — дополнительный сигнальный канал.
	// Его отправитель — горутина-«модератор» (ниже),
	// а получатели — все отправители и получатели dataCh.

	toStop := make(chan string, 1)
	// Канал toStop используется для уведомления модератора,
	// чтобы он закрыл дополнительный сигнальный канал (stopCh).
	// Отправителями выступают любые отправители и получатели dataCh,
	// а получателем — горутина-модератор (ниже).
	// Канал ОБЯЗАТЕЛЬНО должен быть буферизированным.

	var stoppedBy string

	// Модератор
	go func() {
		stoppedBy = <-toStop
		close(stopCh)
	}()

	// Отправители
	for i := 0; i < NumSenders; i++ {
		go func(id string) {
			for {
				value := rand.Intn(Max)
				if value == 0 {
					// Здесь неблокирующая отправка — это попытка
					// уведомить модератора закрыть дополнительный
					// сигнальный канал.
					select {
					case toStop <- "sender#" + id:
					default:
					}
					return
				}

				// Неблокирующее чтение из stopCh нужно, чтобы
				// как можно раньше выйти из горутины-отправителя.
				// Блоки select с try-receive/try-send специально
				// оптимизированы стандартным компилятором Go,
				// поэтому очень эффективны.
				select {
				case <-stopCh:
					return
				default:
				}

				// Даже если stopCh уже закрыт, первая ветка в этом
				// select может не выбираться в некоторых итерациях
				// (и теоретически бесконечно), если отправка в dataCh
				// тоже не блокируется. Если это неприемлемо, то
				// вышеуказанный try-receive обязателен.
				select {
				case <-stopCh:
					return
				case dataCh <- value:
				}
			}
		}(strconv.Itoa(i))
	}

	// Получатели
	for i := 0; i < NumReceivers; i++ {
		go func(id string) {
			defer wgReceivers.Done()

			for {
				// Аналогично отправителю: try-receive нужен,
				// чтобы как можно раньше выйти из горутины-получателя.
				select {
				case <-stopCh:
					return
				default:
				}

				// Даже если stopCh закрыт, первая ветка может
				// не выбираться (и теоретически бесконечно), если
				// чтение из dataCh тоже не блокируется. Если это
				// неприемлемо, вышеуказанный try-receive обязателен.
				select {
				case <-stopCh:
					return
				case value := <-dataCh:
					if value == Max-1 {
						// Тот же приём: уведомляем модератора,
						// чтобы он закрыл дополнительный
						// сигнальный канал.
						select {
						case toStop <- "receiver#" + id:
						default:
						}
						return
					}

					log.Println(value)
				}
			}
		}(strconv.Itoa(i))
	}

	// ...
	wgReceivers.Wait()
	log.Println("stopped by", stoppedBy)
}
```

В этом примере **принцип закрытия канала всё ещё соблюдается**.

Обратите внимание, что размер буфера канала `toStop` равен одному. Это делается для того, чтобы предотвратить потерю первого уведомления, если оно будет отправлено до того, как горутина модератора будет готова принять уведомление от канала `toStop`.

Также можно установить размер буфера канала `toStop` равным сумме числа отправителей и получателей. В этом случае нам не нужно будет использовать блок select с попыткой отправки (try-send) для уведомления модератора.

```go
...
toStop := make(chan string, NumReceivers + NumSenders)
...
			value := rand.Intn(Max)
			if value == 0 {
				toStop <- "sender#" + id
				return
			}
...
				if value == Max-1 {
					toStop <- "receiver#" + id
					return
				}
...
```

### 4. Вариант ситуации "M получателей, один отправитель": запрос на закрытие делается третьей горутиной

Иногда требуется, чтобы сигнал о закрытии был отправлен третьей горутиной. В таких случаях можно использовать дополнительный сигнализирующий канал, чтобы уведомить отправителя о необходимости закрыть основной канал данных. Например:

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 100000
	const NumReceivers = 100
	const NumThirdParties = 15

	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)
	closing := make(chan struct{}) // сигнальный канал (запрос на остановку)
	closed := make(chan struct{})  // сигнал «остановка завершена»
	
	// Функцию stop можно безопасно вызывать многократно.
	stop := func() {
		select {
		case closing <- struct{}{}:
			<-closed
		case <-closed:
		}
	}
	
	// Несколько сторонних (третьих) горутин
	for i := 0; i < NumThirdParties; i++ {
		go func() {
			r := 1 + rand.Intn(3)
			time.Sleep(time.Duration(r) * time.Second)
			stop()
		}() 
	}

	// Отправитель
	go func() {
		defer func() {
			close(closed)
			close(dataCh)
		}()

		for {
			select {
			case <-closing:
				return
			default:
			}

			select {
			case <-closing:
				return
			case dataCh <- rand.Intn(Max):
			}
		}
	}()

	// Получатели
	for i := 0; i < NumReceivers; i++ {
		go func() {
			defer wgReceivers.Done()

			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	wgReceivers.Wait()
}
```

Идея, использованная в функции stop, была взята [из комментария](https://groups.google.com/g/golang-nuts/c/lEKehHH7kZY/m/SRmCtXDZAAAJ) Роджера Пеппе.

## 5. Вариант ситуации с "N отправителями": необходимо закрыть канал данных, чтобы уведомить получателей о завершении передачи данных
В приведённых выше решениях для ситуаций с несколькими отправителями (`N-sender`) мы избегали закрытия каналов данных, чтобы соблюдать **принцип закрытия каналов**. Однако иногда требуется явно закрыть канал данных, чтобы получатели знали, что отправка данных завершена.

В таких случаях можно преобразовать ситуацию с N отправителями в ситуацию с одним отправителем, используя промежуточный канал. Этот промежуточный канал будет иметь только одного отправителя, и мы сможем закрыть его вместо закрытия исходного канала данных.

```go
package main

import (
	"time"
	"math/rand"
	"sync"
	"log"
	"strconv"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // нужно до Go 1.20
	log.SetFlags(0)

	// ...
	const Max = 1000000
	const NumReceivers = 10
	const NumSenders = 1000
	const NumThirdParties = 15

	wgReceivers := sync.WaitGroup{}
	wgReceivers.Add(NumReceivers)

	// ...
	dataCh := make(chan int)     // будет закрыт
	middleCh := make(chan int)   // никогда не закрывается
	closing := make(chan string) // сигнальный канал
	closed := make(chan struct{})

	var stoppedBy string

	// Функцию stop можно безопасно вызывать многократно.
	stop := func(by string) {
		select {
		case closing <- by:
			<-closed
		case <-closed:
		}
	}
	
	// Промежуточный слой
	go func() {
		exit := func(v int, needSend bool) {
			close(closed)
			if needSend {
				dataCh <- v
			}
			close(dataCh)
		}

		for {
			select {
			case stoppedBy = <-closing:
				exit(0, false)
				return
			case v := <-middleCh:
				select {
				case stoppedBy = <-closing:
					exit(v, true)
					return
				case dataCh <- v:
				}
			}
		}
	}()
	
	// Несколько сторонних горутин
	for i := 0; i < NumThirdParties; i++ {
		go func(id string) {
			r := 1 + rand.Intn(3)
			time.Sleep(time.Duration(r) * time.Second)
			stop("3rd-party#" + id)
		}(strconv.Itoa(i))
	}

	// Отправители
	for i := 0; i < NumSenders; i++ {
		go func(id string) {
			for {
				value := rand.Intn(Max)
				if value == 0 {
					stop("sender#" + id)
					return
				}

				select {
				case <-closed:
					return
				default:
				}

				select {
				case <-closed:
					return
				case middleCh <- value:
				}
			}
		}(strconv.Itoa(i))
	}

	// Получатели
	for range [NumReceivers]struct{}{} {
		go func() {
			defer wgReceivers.Done()

			for value := range dataCh {
				log.Println(value)
			}
		}()
	}

	// ...
	wgReceivers.Wait()
	log.Println("stopped by", stoppedBy)
}
```

## Ещё варианты ситуаций?

Наверняка существуют и другие варианты ситуаций, но приведённые выше являются самыми распространёнными и базовыми. Используя каналы (а также другие техники конкурентного программирования) разумно, можно найти решение, которое будет соблюдать принцип закрытия каналов, для каждой возможной ситуации.

## Заключение
Не существует ситуаций, которые заставляют нарушать принцип закрытия каналов. Если вы столкнулись с такой ситуацией, пересмотрите ваш дизайн и перепишите код.

Программирование с использованием каналов в Go похоже на искусство.







