# Техники синхронизации в стандартном пакете `sync`

[Статья](https://go101.org/article/concurrent-synchronization-more.html)

Статья [о применении каналов](https://go101.org/article/channel-use-cases.html) описывает множество способов их использования для синхронизации данных между горутинами. Однако каналы — не единственный механизм синхронизации в Go. **В некоторых случаях другие средства синхронизации могут быть более эффективными и читаемыми**. Далее рассмотрим техники синхронизации, предоставляемые стандартным пакетом `sync`.

Стандартный пакет `sync` **включает несколько типов**, которые позволяют выполнять синхронизацию в специализированных случаях и гарантировать определённый порядок работы с памятью. В таких случаях использование этих механизмов будет более эффективным и лаконичным по сравнению с каналами.

(Обратите внимание: во избежание некорректного поведения не следует копировать значения типов из пакета `sync`)

## Тип `sync.WaitGroup`

Каждый объект `sync.WaitGroup` содержит внутренний счётчик, изначально равный нулю.

Тип `*WaitGroup` предоставляет [три метода](https://go101.org/article/concurrent-synchronization-more.html):

- `Add(delta int)` — изменяет значение счётчика.
- `Done()` — эквивалентен `Add(-1)`.
- `Wait()` — приостанавливает выполнение вызывающей горутины до тех пор, пока счётчик не станет равным нулю.

Для адресуемого значения `WaitGroup` `(wg)`:

- Можно вызвать `wg.Add(delta)`, чтобы изменить значение счётчика, поддерживаемого wg.
- Вызов `wg.Done()` полностью эквивалентен `wg.Add(-1)`.
- Если вызов `wg.Add(delta)` (или `wg.Done()`) приведёт к тому, что счётчик **станет отрицательным, произойдёт паника**.
- Когда горутина вызывает `wg.Wait()`:
  - Если счётчик уже равен нулю, вызов `wg.Wait()` не окажет никакого эффекта (**no-op**).
  - Если счётчик больше нуля, горутина будет заблокирована до тех пор, пока другая горутина не уменьшит счётчик до нуля (обычно с помощью `wg.Done()`). После этого `wg.Wait()` разблокируется и продолжит выполнение.

Обратите внимание, что `wg.Add(delta)`, `wg.Done()` и `wg.Wait()` являются сокращениями для (`&wg).Add(delta)`, `(&wg).Done()` и `(&wg).Wait()`, соответственно.

Обычно `WaitGroup` используется в сценариях, когда одна горутина должна дождаться завершения нескольких других.

```go
package main

import (
	"log"
	"math/rand"
	"sync"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // needed before Go 1.20

	const N = 5
	var values [N]int32

	var wg sync.WaitGroup
	wg.Add(N)
	for i := 0; i < N; i++ {
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			log.Println("Done:", i)
			wg.Done() // <=> wg.Add(-1)
		}()
	}

	wg.Wait()
	// All elements are guaranteed to be
	// initialized now.
	log.Println("values:", values)
}
```

В приведённом выше примере основная горутина ждёт, пока все **N** горутин заполнят соответствующие элементы массива `values`.

Вот возможный результат выполнения:

```go
Done: 4
Done: 1
Done: 3
Done: 0
Done: 2
values: [71 89 50 62 60]
```

Мы можем разделить единственный вызов метода `Add` в приведённом выше примере на несколько отдельных вызовов.

```go
...
	var wg sync.WaitGroup
	for i := 0; i < N; i++ {
		wg.Add(1) // will be invoked N times
		i := i
		go func() {
			values[i] = 50 + rand.Int31n(50)
			wg.Done()
		}()
	}
...
```

Метод `Wait` можно вызывать в нескольких горутинах. Когда счётчик становится равным нулю, все ожидающие горутины будут уведомлены одновременно, в режиме широковещательной рассылки.

```go
func main() {

	const N = 5
	var values [N]int32

	var wgA, wgB sync.WaitGroup
	wgA.Add(N)
	wgB.Add(1)

	for i := 0; i < N; i++ {
		go func() {
			wgB.Wait() // wait a notification
			log.Printf("values[%v]=%v \n", i, values[i])
			wgA.Done()
		}()
	}

	// The loop is guaranteed to finish before
	// any above wg.Wait calls returns.
	for i := 0; i < N; i++ {
		values[i] = 50 + rand.Int31n(50)
	}
	// Make a broadcast notification.
	wgB.Done()
	wgA.Wait()
}
```

Значение `WaitGroup` можно использовать повторно после того, как один вызов метода `Wait` завершится. Однако важно помнить, что каждый вызов `Add` с положительным значением `delta`, который выполняется, **когда счётчик равен нулю**, должен происходить перед любым вызовом `Wait`, иначе могут возникнуть **гонки данных (data races)**.

## Тип `sync.Once`

Значение `*sync.Once` имеет метод `Do(f func())`, который принимает единственный параметр типа `func()`.

Для адресуемого значения `Once` `o` вызов метода `o.Do()`, который является сокращением `(&o).Do()`, может выполняться одновременно в нескольких горутинах. Аргументы этих вызовов `o.Do()` должны **(но не обязаны) быть одним и тем же значением функции**.

Среди всех вызовов метода `o.Do` будет выполнена **ровно одна переданная функция**. Выполняемая функция гарантированно завершится до того, как любой вызов `o.Do` вернёт управление. Другими словами, код внутри переданной функции гарантированно выполнится перед возвратом из любого вызова `o.Do`.

Обычно `Once` используется для того, чтобы гарантировать, что определённый фрагмент кода выполнится ровно один раз в условиях конкурентного программирования.

Пример:

```go
package main

import (
	"log"
	"sync"
)

func main() {
	log.SetFlags(0)

	x := 0
	doSomething := func() {
		x++
		log.Println("Hello")
	}

	var wg sync.WaitGroup
	var once sync.Once
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			once.Do(doSomething)
			log.Println("world!")
		}()
	}

	wg.Wait()
	log.Println("x =", x) // x = 1
}
```

В приведённом примере слово "Hello" будет напечатано только один раз, но "world!" будет выведено пять раз. И при этом "Hello" **гарантированно будет выведено до всех пяти** "world!".

## Типы `sync.Mutex` и `sync.RWMutex`

Типы `*sync.Mutex` и `*sync.RWMutex` реализуют [интерфейс `sync.Locker`](https://go101.org/article/concurrent-synchronization-more.html). Они оба имеют два метода: `Lock` и `Unlock`, которые предотвращают одновременное использование данных несколькими пользователями.

Кроме методов `Lock` и `Unlock`, тип `*RWMutex` имеет два дополнительных метода: `RLock` и `RUnlock`, которые позволяют избежать ситуации, когда одновременно один писатель и несколько читателей используют одни и те же данные, при этом разрешая нескольким читателям получать доступ к данным одновременно.

(Обратите внимание, что термины **"читатель данных"** и **"писатель данных"** здесь не следует воспринимать буквально. Читатель данных может изменять данные, а писатель данных может только читать данные.)

Значение `Mutex` часто называется мьютексом (mutex — сокращение от mutual exclusion lock). **Значение нулевого мьютекса (по умолчанию) является разблокированным**. Мьютекс можно заблокировать только в случае, если он находится в разблокированном состоянии. Иными словами, как только значение мьютекса заблокировано с помощью вызова `m.Lock()`, любое последующее обращение к этому мьютексу для блокировки приведёт к тому, что горутина будет блокироваться до тех пор, пока мьютекс не будет разблокирован (через вызов `m.Unlock()`).

Примечание: вызовы `m.Lock()` и `m.Unlock()` являются сокращениями для `(&m).Lock()` и `(&m).Unlock()` соответственно.

Пример использования `sync.Mutex`:

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

type Counter struct {
	m sync.Mutex
	n uint64
}

func (c *Counter) Value() uint64 {
	c.m.Lock()
	defer c.m.Unlock()
	return c.n
}

func (c *Counter) Increase(delta uint64) {
	c.m.Lock()
	c.n += delta
	c.m.Unlock()
}

func main() {
	var c Counter
	for i := 0; i < 100; i++ {
		go func() {
			for k := 0; k < 100; k++ {
				c.Increase(1)
			}
		}()
	}

	// The loop is just for demo purpose.
	for c.Value() < 10000 {
		runtime.Gosched()
	}
	fmt.Println(c.Value()) // 10000
}
```

В приведённом примере значение `Counter` использует поле `Mutex`, чтобы гарантировать, что поле `n` этого `Counter` никогда не будет использоваться несколькими горутинами одновременно.

### `sync.RWMutex`
Значение `RWMutex` часто называют блокировкой с разделением прав доступа для чтения и записи (reader+writer mutual exclusion lock). Оно содержит два типа блокировок: блокировку записи (`write lock`) и блокировку чтения (`read lock`).

По умолчанию (нулевое значение RWMutex) обе блокировки находятся в разблокированном состоянии. Для адресуемого значения `RWMutex` (например, `rwm`):

- Писатели данных могут заблокировать блокировку записи с помощью метода `rwm.Lock()`.
- Читатели данных могут заблокировать блокировку чтения с помощью метода `rwm.RLock()`.

Разблокировка записи и чтения осуществляется методами `rwm.Unlock()` и `rwm.RUnlock()` соответственно.

### Механизм блокировки
Блокировка чтения `rwm` поддерживает счётчик, который:

- Увеличивается на единицу при успешном вызове `rwm.RLock()`.
- Уменьшается на единицу при вызове `rwm.RUnlock()`.
- Если счётчик равен нулю, значит блокировка чтения не активна (разблокирована).
- Если счётчик больше нуля, значит блокировка чтения активна (заблокирована), при этом её могут удерживать несколько читателей одновременно.

Примечание: `rwm.Lock()`, `rwm.Unlock()`, `rwm.RLock()` и `rwm.RUnlock()` являются сокращениями для `(&rwm).Lock()`, `(&rwm).Unlock()`, `(&rwm).RLock()` и `(&rwm).RUnlock()` соответственно.

### Основные правила работы RWMutex

1. **Блокировка записи (`rwm.Lock()`) возможна только если ни одна из блокировок (чтения или записи) в данный момент не активна**.
   - В любой момент **блокировку записи** может удерживать **не более одного писателя**.
   - Блокировки чтения и записи **не могут быть активны одновременно**.

2. **Если блокировка записи активна (`rwm.Lock()`), то все новые попытки заблокировать запись или чтение будут заблокированы до тех пор, пока запись не будет разблокирована (`rwm.Unlock()`).**

3. **Если блокировка чтения активна (rwm.RLock()), то:**

	- Новые попытки заблокировать запись (`rwm.Lock()`) будут заблокированы до тех пор, пока все блокировки чтения не будут сняты (`rwm.RUnlock()`).
	- Новые попытки заблокировать чтение (`rwm.RLock()`) будут успешными, если они выполняются до заблокированных попыток записи.

4. **Приоритет блокировки записи:**

	Если в данный момент блокировка чтения активна, и уже есть заблокированная попытка записи (`rwm.Lock()`), то **все новые попытки заблокировать чтение после этой записи также будут заблокированы**. Это предотвращает бесконечную блокировку чтения.

5. **Приоритет блокировки чтения:**
	Если в данный момент блокировка записи активна, то после её освобождения (`rwm.Unlock()`) все ранее заблокированные попытки чтения (`rwm.RLock()`) будут выполнены до ранее заблокированных новых попыток записи. Это предотвращает бесконечную блокировку записи.

Эти два правила обеспечивают справедливое распределение блокировок между читателями и писателями.

**Важно**

Блокировки **не привязаны к конкретной горутине**. Это означает, что одна горутина может заблокировать мьютекс, а другая — разблокировать его. Мьютекс не отслеживает, какая горутина выполнила блокировку или разблокировку.


В предыдущем примере с `Counter` можно заменить поле m типа `sync.Mutex` на `sync.RWMutex`. Это позволит повысить производительность в сценариях, когда метод `Value()` вызывается часто, а метод `Increase()` — редко.


```go
...
type Counter struct {
	//m sync.Mutex
	m sync.RWMutex
	n uint64
}

func (c *Counter) Value() uint64 {
	//c.m.Lock()
	//defer c.m.Unlock()
	c.m.RLock()
	defer c.m.RUnlock()
	return c.n
}
...
```

Ещё один сценарий использования значений `sync.RWMutex` — это разбиение задачи записи на несколько небольших операций. Пожалуйста, прочитайте следующий раздел для примера.

Согласно двум последним упомянутым правилам, следующая программа вполне может вывести `abdc`.

```go
package main

import (
	"fmt"
	"time"
	"sync"
)

func main() {
	var m sync.RWMutex
	go func() {
		m.RLock()
		fmt.Print("a")
		time.Sleep(time.Second)
		m.RUnlock()
	}()
	go func() {
		time.Sleep(time.Second * 1 / 4)
		m.Lock()
		fmt.Print("b")
		time.Sleep(time.Second)
		m.Unlock()
	}()
	go func() {
		time.Sleep(time.Second * 2 / 4)
		m.Lock()
		fmt.Print("c")
		m.Unlock()
	}()
	go func () {
		time.Sleep(time.Second * 3 / 4)
		m.RLock()
		fmt.Print("d")
		m.RUnlock()
	}()
	time.Sleep(time.Second * 3)
	fmt.Println()
}
```

Обратите внимание, что приведённый выше пример предназначен только для объяснения. Он использует вызовы `time.Sleep` для синхронизации конкурентных процессов, что является [плохой практикой для промышленного кода](https://go101.org/article/concurrent-common-mistakes.html#sleep).

Значения `sync.Mutex` и `sync.RWMutex` также могут использоваться для создания уведомлений, хотя существуют и более подходящие способы решения этой задачи. Вот пример, в котором уведомление создаётся с использованием значения `sync.Mutex`.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var m sync.Mutex
	m.Lock()
	go func() {
		time.Sleep(time.Second)
		fmt.Println("Hi")
		m.Unlock() // make a notification
	}()
	m.Lock() // wait to be notified
	fmt.Println("Bye")
}
```

В приведённом выше примере текст `Hi` гарантированно будет выведен перед текстом `Bye`.
О гарантиях порядка памяти, обеспечиваемых `sync.Mutex` и `sync.RWMutex`, можно прочитать в документации о [гарантиях порядка памяти в Go](https://go101.org/article/memory-model.html#mutex).

## Тип `sync.Cond`

Тип `sync.Cond` предоставляет эффективный способ для организации уведомлений между горутинами.

Каждое значение `sync.Cond` содержит поле `L` типа `sync.Locker`. Чаще всего в качестве `L` используется `*sync.Mutex` или `*sync.RWMutex`.

Тип `*sync.Cond` имеет [три метода](https://pkg.go.dev/sync#Cond):
- `Wait()`,
- `Signal()`,
- `Broadcast()`.

Кроме того, каждое значение `sync.Cond` поддерживает очередь ожидания горутин (FIFO — "первый вошёл, первый вышел").

Для адресуемого значения `sync.Cond` (например, `c`):

- `c.Wait()` должен вызываться только в заблокированном состоянии `c.L`, иначе произойдёт `panic`. Вызов `c.Wait()`:

	1. Добавляет вызывающую горутину в очередь ожидания `c`.
	2. Вызывает `c.L.Unlock()`, освобождая блокировку `c.L`.
	3. Переводит горутину в состояние блокировки
   
   (она будет разблокирована другой горутиной вызовом `c.Signal()` или `c.Broadcast()` позже)
   
   Когда горутина разблокируется, метод `c.L.Lock()` снова установит блокировку `c.L`. Только после успешного захвата блокировки метод `c.Wait()` завершит выполнение.

- `c.Signal()` разблокирует первую горутину в очереди ожидания `c` (и удалит её из очереди), если очередь не пуста.

- `c.Broadcast()` разблокирует все горутины в очереди ожидания `c` (и удалит их из нее), если очередь не пуста.

Методы `c.Wait()`, `c.Signal()` и `c.Broadcast()` являются сокращениями для `(&c).Wait()`, `(&c).Signal()`, `(&c).Broadcast()`.

Методы `c.Signal()` и `c.Broadcast()` обычно используются для уведомления о том, что условие изменилось.
Как правило, `c.Wait()` вызывается в цикле, который проверяет, выполнено ли условие.

### Идиоматичное использование `sync.Cond`
Обычно одна горутина ожидает изменения условия, а другие горутины изменяют условие и отправляют уведомления.

Вот пример:

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

func main() {
	const N = 10
	var values [N]string

	cond := sync.NewCond(&sync.Mutex{})

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d) // simulate a workload

			// Changes must be made when
			// cond.L is locked.
			cond.L.Lock()
			values[i] = string('a' + i)

			// Notify when cond.L lock is locked.
			cond.Broadcast()
			cond.L.Unlock()

			// "cond.Broadcast()" can also be put
			// here, when cond.L lock is unlocked.
			//cond.Broadcast()
		}(i)
	}

	// This function must be called when
	// cond.L is locked.
	checkCondition := func() bool {
		fmt.Println(values)
		for i := 0; i < N; i++ {
			if values[i] == "" {
				return false
			}
		}
		return true
	}

	cond.L.Lock()
	defer cond.L.Unlock()
	for !checkCondition() {
		// Must be called when cond.L is locked.
		cond.Wait()
	}
}
```

Один из возможных результатов:
```go
[         ]
[     f    ]
[  c   f    ]
[  c   f  h  ]
[ b c   f  h  ]
[a b c   f  h  j]
[a b c   f g h i j]
[a b c  e f g h i j]
[a b c d e f g h i j]
```

Поскольку в данном примере только одна горутина (главная горутина) ожидает разблокировки, вызов `cond.Broadcast()` можно заменить на `cond.Signal()`.
Как указано в комментариях, `cond.Broadcast()` и `cond.Signal()` не обязательно должны вызываться при заблокированном `cond.L`.

Чтобы избежать состояния **гонки данных (data race)**, каждая из десяти частей пользовательского условия должна изменяться только при заблокированном `cond.L`.
Кроме того, функция `checkCondition` и метод `cond.Wait` также должны вызываться при заблокированном `cond.L`.

Фактически, в указанном выше примере поле `cond.L` может быть `*sync.RWMutex`, а каждая из десяти частей пользовательского условия может изменяться при удержании `read lock (RLock) cond.L`, как показано в следующем коде:

```go
...
	cond := sync.NewCond(&sync.RWMutex{})
	cond.L.Lock()

	for i := 0; i < N; i++ {
		d := time.Second * time.Duration(rand.Intn(10)) / 10
		go func(i int) {
			time.Sleep(d)
			cond.L.(*sync.RWMutex).RLock()
			values[i] = string('a' + i)
			cond.L.(*sync.RWMutex).RUnlock()
			cond.Signal()
		}(i)
	}
...
```

В приведённом выше примере значение `sync.RWMutex` используется нетипично.
Его read lock (`RLock`) удерживается некоторыми горутинами, которые изменяют элементы массива,
а его write lock (`Lock`) используется главной горутиной для чтения элементов массива.

Пользовательское условие, контролируемое значением `Cond`, может быть пустым.
В таких случаях значение `Cond` используется исключительно для уведомлений.

Например, следующая программа выведет `abc` или `bac`.

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}
	wg.Add(1)
	cond := sync.NewCond(&sync.Mutex{})
	cond.L.Lock()
	go func() {
		cond.L.Lock()
		go func() {
			cond.L.Lock()
			cond.Broadcast()
			cond.L.Unlock()
		}()
		cond.Wait()
		fmt.Print("a")
		cond.L.Unlock()
		wg.Done()
	}()
	cond.Wait()
	fmt.Print("b")
	cond.L.Unlock()
	wg.Wait()
	fmt.Println("c")
}
```

Если это необходимо, несколько значений `sync.Cond` могут совместно использовать один и тот же `sync.Locker`. Однако на практике такие случаи встречаются редко.

