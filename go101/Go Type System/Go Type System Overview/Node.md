# Go Type System Overview

[Статья](https://go101.org/article/type-system-overview.html)

 В этой статье рассматриваются различные типы в языке Go и связанные с ними концепции. Понимание этих фундаментальных понятий необходимо для глубокого освоения Go.

## Концепция: Базовые типы

Встроенные базовые типы в Go уже обсуждались в статье ["Встроенные базовые типы и базовые литералы значений"](https://go101.org/article/basic-types-and-value-literals.html). Для полноты текущей статьи эти встроенные базовые типы перечислены здесь:

- Встроенный строковый тип: `string`.
- Встроенный булевый тип: `bool`.
- Встроенные числовые типы:
    - Целочисленные: `int8`, `uint8 (byte)`, `int16`, `uint16`, `int32 (rune)`, `uint32`, `int64`, `uint64`, `int`, `uint`, `uintptr`.
    - С плавающей запятой: `float32`, `float64`.
    - Комплексные: `complex64`, `complex128`.

Обратите внимание, что `byte` — это встроенный псевдоним для `uint8`, а `rune` — для `int32`. Мы также можем объявлять пользовательские псевдонимы типов.

За исключением [строковых типов](https://go101.org/article/string.html), серия статей Go 101 не будет подробно объяснять другие базовые типы.

Эти 17 встроенных базовых типов являются предопределёнными.

## Концепция: Составные типы

Go поддерживает следующие составные типы:

- [Указательные типы](https://go101.org/article/pointer.html) — аналогичны указателям в C.
- [Структурные типы](https://go101.org/article/struct.html) — аналогичны структурам в C.
- [Функциональные типы](https://go101.org/article/function.html) — функции являются типами первого класса в Go.
- [Контейнерные типы](https://go101.org/article/container.html):
    - Массивы — контейнеры фиксированной длины.
    - Срезы — контейнеры с динамической длиной и ёмкостью.
    - Отображения (map) — ассоциативные массивы (или словари). Стандартный компилятор Go реализует отображения как хеш-таблицы.
- [Канальные типы](https://go101.org/article/channel.html) — используются для синхронизации данных между горутинами (зелёными потоками в Go).
- [Интерфейсные типы](https://go101.org/article/interface.html) — играют ключевую роль в рефлексии и полиморфизме.

Безымянные составные типы могут обозначаться с помощью соответствующих литералов типов. Ниже приведены некоторые примеры литерального представления всех видов безымянных составных типов (именованные и безымянные типы будут объяснены ниже):

```go
// Предположим, что T — произвольный тип, а Tkey — тип, поддерживающий сравнение (== и !=).

*T         // указательный тип
[5]T       // массивный тип
[]T        // тип среза
map[Tkey]T // тип отображения

// тип структуры
struct {
    name string
    age  int
}

// тип функции
func(int) (bool, string)

// тип интерфейса
interface {
    Method0(string) int
    Method1() (int, bool)
}

// некоторые типы каналов
chan T
chan<- T
<-chan T
```

[Сравнимые и несравнимые типы](https://go101.org/article/type-system-overview.html#types-not-support-comparison) будут объяснены ниже.

## Факт: Виды типов

Каждый из вышеупомянутых базовых и составных типов соответствует одному виду типов. Кроме этих видов, небезопасные указательные типы, введённые в [стандартном пакете `unsafe`](https://golang.org/pkg/unsafe), также относятся к одному из видов типов в Go. Таким образом, по состоянию на Go 1.24, в Go существует 26 видов типов.

## Синтаксис: Определения типов

**Определение типа (type definition)** (или *объявление определения типа*, первоначально называвшееся **объявлением типа**) было единственным способом объявления типов до Go 1.9. Начиная с Go 1.9, определение типа стало одной из двух форм объявлений типов. Новая форма называется **объявлением псевдонима типа**, которое будет рассмотрено в разделе ниже.

В Go мы можем определять новые типы, используя следующую форму. В этом синтаксисе `type` является ключевым словом.

```go
// Определение одного нового типа.
type NewTypeName SourceType

// Определение нескольких новых типов вместе.
type (
    NewTypeName1 SourceType1
    NewTypeName2 SourceType2
)
```

Новые имена типов должны быть идентификаторами. Однако следует отметить, что имена типов, объявленные на уровне пакета, не могут быть [`init`](https://go101.org/article/packages-and-imports.html#init).

Второе объявление типа в приведённом выше примере включает две спецификации типов. Если объявление типа содержит более одной спецификации типа, спецификации типов должны быть заключены в пару скобок `()`.

Обратите внимание:

- новый определённый тип и его соответствующий исходный тип в определениях типов являются двумя различными типами;
- два типа, определённые в двух разных определениях типов, всегда являются двумя различными типами;
- новый определённый тип и его исходный тип будут иметь одинаковый базовый тип (определение базовых типов будет рассмотрено ниже), и их значения могут быть преобразованы друг в друга.
- типы могут быть определены внутри тел функций.

Примеры определения типов:

```go
// Следующие новые определённые и исходные типы — это все 
// базовые типы. Исходные типы все предопределены.
type (
	MyInt int
	Age   int
	Text  string
)

// Следующие новые определённые и исходные типы — это все
// составные типы. Исходные типы все являются анонимными.
type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

func f() {
	// Имена трёх определённых типов 
	// могут использоваться только внутри этой функции.
	type PersonAge map[string]int
	type MessageQueue chan string
	type Reader interface{Read([]byte) int}
}
```

