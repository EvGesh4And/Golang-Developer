# Интерфейсы в Go

Интерфейсные типы — это особый вид типов в Go. Интерфейсы играют несколько важных ролей в языке. В основе своей интерфейсные типы обеспечивают поддержку так называемой упаковки значений (value boxing) в Go. Благодаря упаковке значений становятся возможными отражение (reflection) и полиморфизм.

Начиная с версии 1.18, Go поддерживает пользовательские дженерики (обобщения). В рамках дженериков интерфейсные типы могут (и всегда используются) в качестве ограничений типов (type constraints). Фактически, все ограничения типов — это интерфейсные типы. До версии Go 1.18 все интерфейсные типы могли использоваться как обычные типы значений. Однако начиная с Go 1.18, некоторые интерфейсные типы могут использоваться **только** как ограничения типов. Интерфейсные типы, которые можно использовать как типы значений, называются **базовыми интерфейсными типами** (basic interface types).

Эта статья была написана в основном до появления поддержки дженериков в Go, поэтому она сосредоточена преимущественно на базовых интерфейсах. За подробной информацией об интерфейсах, предназначенных только для ограничений, обратитесь к книге [Go generics 101](https://go101.org/generics/101.html).

## Интерфейсные типы и множества типов

Интерфейсный тип определяет некоторые (типовые) требования. Все неинтерфейсные типы, удовлетворяющие этим требованиям, образуют **множество типов** (type set), которое называется **множеством типов интерфейсного типа**.

Требования, определяемые для **интерфейсного типа (interface type)**, выражаются через встраивание
некоторых **элементов интерфейса (interface elements)** в определение интерфейса.
На данный момент (Go 1.25) существуют два вида таких элементов: **элементы методов (method elements)** и **элементы типов (type elements)**.

* **Элемент метода** представлен в виде *спецификации метода* ([method specification](https://go101.org/article/method.html#method-set)).
  Имя метода в интерфейсе не может быть `_` (пустым идентификатором).
* **Элемент типа** может быть *именем типа*, *литералом типа*, *приближённым типом* (approximation type) или *объединением типов* (type union).
  В данной статье рассматриваются только имена и литералы типов, которые обозначают интерфейсные типы.

Например, [предопределённый интерфейсный тип **`error`**](https://golang.org/pkg/builtin/#error),
чьё определение показано ниже, встраивает спецификацию метода `Error() string`.
В этом определении `interface{...}` — это литерал интерфейсного типа,
а слово `interface` является ключевым словом Go.

```go
type error interface {
	Error() string
}
```

Можно также сказать, что интерфейс `error` напрямую определяет метод `Error() string`.
Множество его типов состоит из всех **неинтерфейсных типов**,
у которых имеется [метод](https://go101.org/article/method.html) с такой сигнатурой.
Теоретически, множество типов бесконечно.
На практике, в пределах конкретного проекта оно конечно.

Ниже приведены другие примеры определений интерфейсов и псевдонимов (alias):

```go
// Этот интерфейс прямо определяет два метода и
// встраивает два других интерфейсных типа:
// один по имени, другой — в виде литерала.
type ReadWriteCloser = interface {
	Read(buf []byte) (n int, err error)
	Write(buf []byte) (n int, err error)
	error                      // имя типа
	interface{ Close() error } // литерал типа
}

// Этот интерфейс встраивает приближённый (approximation) тип.
// Его множество типов включает все типы с базовым типом []byte.
type AnyByteSlice = interface {
	~[]byte
}

// Этот интерфейс использует объединение типов.
// Его множество включает 6 типов: uint, uint8, uint16, uint32, uint64 и uintptr.
type Unsigned interface {
	uint | uint8 | uint16 | uint32 | uint64 | uintptr
}
```

Встраивание одного интерфейсного типа (будь то по имени или через литерал)
в другой эквивалентно (рекурсивному) разворачиванию его элементов в текущий интерфейс.

Например, интерфейс, обозначенный псевдонимом `ReadWriteCloser`,
эквивалентен следующему литералу интерфейса, который напрямую определяет четыре метода:

```go
interface {
	Read(buf []byte) (n int, err error)
	Write(buf []byte) (n int, err error)
	Error() string
	Close() error
}
```

Множество типов такого интерфейса состоит из всех неинтерфейсных типов, у которых определены все эти четыре метода. Множество бесконечно, но точно является подмножеством множества типов интерфейса `error`.

> Обратите внимание: до версии Go 1.18 в интерфейсах можно было встраивать только **имена интерфейсных типов**.

Интерфейсы, приведённые ниже, называются **пустыми интерфейсами** (blank interface types),
так как не содержат ни одного элемента:

```go
// Неименованный пустой интерфейс.
interface{}

// Определённый тип Nothing — это тоже пустой интерфейс.
type Nothing interface{}
```

Начиная с Go 1.18, введён предопределённый псевдоним `any`, обозначающий пустой интерфейс `interface{}`.

Множество типов пустого интерфейса включает **все неинтерфейсные типы**.


## Наборы методов типов (Method Sets of Types)

У каждого типа в Go существует связанный с ним [**набор методов** (method set)](https://go101.org/article/method.html#method-set).

* Для **неинтерфейсного типа** его набор методов состоит из сигнатур [**всех объявленных для него методов** (явных и неявных)](https://go101.org/article/method.html).
* Для **интерфейсного типа** его набор методов состоит из всех сигнатур методов, указанных **непосредственно** или **через вложенные интерфейсы**.

В примерах из предыдущего раздела:

* набор методов интерфейса `ReadWriteCloser` содержит **четыре метода**;
* набор методов предопределённого интерфейса `error` содержит **один метод**;
* набор методов **пустого интерфейса** (interface{}) — **пустой**.

Для удобства набор методов типа часто называют также **набором методов значения этого типа**.

## Базовые интерфейсные типы (Basic Interface Types)

**Базовые интерфейсные типы** — это такие интерфейсные типы, которые можно использовать в качестве **типов значений**.
Интерфейсные типы, которые нельзя использовать как типы значений, называются **только-ограничивающими типами** (constraint-only interface types).

На текущий момент (Go 1.25), любой базовый интерфейсный тип может быть полностью определён через **набор методов** (возможно, пустой). Иными словами, базовому интерфейсу **не нужны элементы типов** для определения.

Из примеров в предыдущем разделе:

* интерфейс `ReadWriteCloser` является **базовым типом**;
* интерфейсы `Unsigned` и `AnyByteSlice` — **не базовые**, они используются **только как ограничения** типов.

Также к базовым относятся:

* **пустые интерфейсы** (`interface{}`),
* предопределённый интерфейс `error`.

Два **неименованных базовых интерфейсных типа** считаются идентичными, если у них **одинаковые наборы методов**.
Важно: методы с неэкспортируемыми именами (начинающимися с **маленькой буквы**) из **разных пакетов** считаются **разными**, даже если имена совпадают.

## Реализация интерфейсов (Implementations)

Если **неинтерфейсный тип** входит в **множество типов интерфейса**, говорят, что **он реализует этот интерфейс**.

Если множество типов одного интерфейса является подмножеством множества типов другого интерфейса — то **первый интерфейс реализует второй**.

* Интерфейс **всегда реализует сам себя**, так как его множество типов — подмножество самого себя.
* Два интерфейса с **одинаковыми наборами методов** реализуют друг друга.
* Два неименованных интерфейса считаются **одинаковыми**, если у них совпадают **множества типов**.

Если тип `T` реализует интерфейс `X`, то **набор методов `T` должен содержать все методы `X`** (то есть быть его супермножеством), независимо от того, `T` — интерфейс или нет.

> В общем случае — не наоборот.
> Но если `X` — **базовый интерфейс**, то и обратное верно.

Например, интерфейс `ReadWriteCloser` из предыдущего раздела реализует интерфейс `error`.


**Реализация интерфейсов в Go всегда неявная.**
Компилятор **не требует** указывать явно, что тип реализует интерфейс.
В Go **нет ключевого слова `implements`**.
Компилятор **автоматически проверяет** соответствие при необходимости.


Пример:

```go
type Aboutable interface {
	About() string
}

type Book struct {
	name string
	// другие поля ...
}

func (book *Book) About() string {
	return "Book: " + book.name
}

type MyInt int

func (MyInt) About() string {
	return "I'm a custom integer value"
}
```

В этом примере типы `*Book`, `MyInt` и `*MyInt` реализуют интерфейс `Aboutable`,
так как в их наборах методов присутствует метод `About() string`.

Такая **неявная реализация** позволяет типам из сторонних или стандартных пакетов
**автоматически удовлетворять интерфейсам**, определённым в пользовательском коде.

Пример: если объявить следующий интерфейс:

```go
type DatabaseStorer interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Prepare(query string) (*sql.Stmt, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
}
```

то типы `DB` и `Tx` из [**стандартного пакета `database/sql`**](https://golang.org/pkg/database/sql/)
автоматически будут **реализовывать этот интерфейс**,
так как они содержат все указанные методы.

Также важно:
так как **множество типов пустого интерфейса** включает **все неинтерфейсные типы**,
**любой тип** реализует **пустой интерфейс** (`interface{}` / `any`).

Это — **фундаментальное свойство Go**.


## Упаковка значений (Value Boxing)

Напомним: на текущий момент (Go 1.25) **типами интерфейсных значений могут быть только базовые интерфейсные типы**.
Во всех последующих частях этой статьи, под **типом значения** понимается либо **неинтерфейсный тип**, либо **базовый интерфейсный тип**.
Ограничивающие интерфейсные типы (constraint-only) **в этом контексте не используются**.

Каждое интерфейсное значение можно представить как **"коробку" (box)**,
в которую **упаковано (boxed)** значение неинтерфейсного типа.
Чтобы упаковать значение неинтерфейсного типа в интерфейсное значение,
его тип должен **реализовывать тип интерфейса**.

Если тип `T` реализует (базовый) интерфейс `I`,
то значение типа `T` может **неявно приводиться** к типу `I`.
Иными словами, оно [**может быть присвоено**](https://go101.org/article/constants-and-variables.html#assignment) переменной типа `I`.

Когда значение типа `T` присваивается переменной типа `I`:

* если `T` — **неинтерфейсный тип**, то:

  * создаётся **копия значения `T`**, которая упаковывается в интерфейс `I`;
  * сложность копирования — `O(n)`, где `n` — размер значения;
  * (в стандартном компиляторе Go существуют оптимизации для уменьшения затрат — см. книгу [*Go Optimizations 101*](https://go101.org/optimizations/101.html)).
* если `T` — **интерфейсный тип**, то:

  * копируется **упакованное значение из `T`** в новую "коробку" `I`;
  * сложность копирования — `O(1)`;
  * с версии Go 1.5, если динамическое значение не указатель — оно копируется в новое место в памяти, и интерфейс указывает на эту копию.

Информация о **типе упакованного значения** также сохраняется внутри интерфейсного значения.
(Об этом подробнее далее.)

Когда значение упаковано в интерфейс, его называют:

* **динамическим значением** интерфейса,
* а его тип — **динамическим типом** интерфейса.

Прямой доступ к динамическому значению — **только на чтение**,
однако можно заменить всё динамическое значение на новое.

В Go **нулевое значение интерфейсного типа** представлено предопределённым идентификатором `nil`.
В таком значении **ничего не упаковано**.
Присваивание `nil` интерфейсной переменной **очищает** динамическое значение.

> Обратите внимание:
> хотя `nil` используется как нулевое значение **для многих неинтерфейсных типов** (например, `*T`, `map`, `slice`),
> **упакованное `nil`-значение — всё равно что-то упакованное**.
> Такое значение **не считается nil-интерфейсом**.

Поскольку **любой тип реализует пустой интерфейс**,
любой неинтерфейсный тип **можно упаковать в `interface{}` / `any`**.
Именно поэтому `interface{}` в Go можно считать аналогом типа `any` в других языках.

Если **неопределённое значение** (untyped literal, кроме `nil`)
присваивается переменной типа `interface{}`, оно сначала
**неявно преобразуется в значение своего "дефолтного" типа**.

---

Пример с упаковкой значений в интерфейсы:

```go
package main

import "fmt"

type Aboutable interface {
	About() string
}

type Book struct {
	name string
}

func (book *Book) About() string {
	return "Book: " + book.name
}

func main() {
	// Упаковка *Book в интерфейс Aboutable
	var a Aboutable = &Book{"Go 101"}
	fmt.Println(a) // &{Go 101}

	// i — пустой интерфейс
	var i interface{} = &Book{"Rust 101"}
	fmt.Println(i) // &{Rust 101}

	// Aboutable реализует interface{}, можно присвоить
	i = a
	fmt.Println(i) // &{Go 101}
}
```

Функция `fmt.Println` имеет такую сигнатуру:

```go
func Println(a ...interface{}) (n int, err error)
```

Поэтому она может принимать **аргументы любого типа**.

Другой пример — упаковка разных значений в пустой интерфейс:

```go
package main

import "fmt"

func main() {
	var i interface{}

	i = []int{1, 2, 3}
	fmt.Println(i) // [1 2 3]

	i = map[string]int{"Go": 2012}
	fmt.Println(i) // map[Go:2012]

	i = true
	fmt.Println(i) // true

	i = 1
	fmt.Println(i) // 1

	i = "abc"
	fmt.Println(i) // abc

	// Очистить интерфейс
	i = nil
	fmt.Println(i) // <nil>
}
```

Компиляторы Go при компиляции создают **глобальную таблицу типов**,
в которой хранятся сведения о:

* виде типа ([kind](https://go101.org/article/type-system-overview.html#type-kinds)),
* его методах и полях,
* базовом типе (для контейнеров),
* размере типа и прочем.

Во время выполнения, при упаковке значения в интерфейс:

* рантайм анализирует пару типов (динамический и интерфейсный);
* создаёт структуру **информации реализации**;
* сохраняет эту информацию в интерфейсном значении;
* одна и та же пара анализируется только **один раз**, далее кэшируется в глобальной карте.

> Количество записей в этой карте **не уменьшается**.
> Интерфейсное значение содержит [**указатель на кэшированную реализацию**](https://go101.org/article/value-part.html#interface-structure).


Информация реализации для каждой пары (интерфейсный тип, динамический тип) включает:

* сведения о **динамическом типе** (обычно неинтерфейсный тип);
* **таблицу методов** — срез, содержащий реализации всех методов, указанных в интерфейсе и определённых в типе.

Эти данные необходимы для реализации двух ключевых возможностей Go:

* [**Рефлексия**](https://go101.org/article/interface.html#reflection) — использует информацию о динамическом типе;
* **Полиморфизм** — основан на таблице методов (подробнее в следующем разделе).

## Полиморфизм (Polymorphism)

**Полиморфизм** — это одна из ключевых возможностей, которую предоставляют интерфейсы,
и важная особенность языка Go.

Когда **значение неинтерфейсного типа `t`** (с типом `T`)
**упаковывается** в интерфейсное значение `i` (с типом `I`),
вызов метода, определённого в интерфейсе `I`,
через переменную `i` фактически вызывает **соответствующий метод значения `t` типа `T`**.

Иными словами:
**вызов метода у интерфейсного значения на самом деле вызывает метод динамического значения, хранящегося внутри интерфейса**.

Пример: вызов `i.m()` вызывает `t.m()`.

Если в переменной интерфейсного типа `i` упакованы значения разных типов,
то при вызове одного и того же метода поведение будет разным.
Это и есть **полиморфизм**.

Когда вызывается `i.m()`,
используется **таблица методов**, хранящаяся в информации реализации,
связанной с интерфейсом `i`.
Так как таблица — это срез (slice), поиск и вызов метода происходит быстро — через обращение по индексу.

> ⚠️ Вызов метода у `nil`-интерфейса приводит к panic во время выполнения,
> так как там нет упакованного значения и таблицы методов.


Пример:

```go
package main

import "fmt"

type Filter interface {
	About() string
	Process([]int) []int
}

// Удаляет дубликаты
type UniqueFilter struct{}
func (UniqueFilter) About() string {
	return "remove duplicate numbers"
}
func (UniqueFilter) Process(inputs []int) []int {
	outs := make([]int, 0, len(inputs))
	seen := make(map[int]bool)
	for _, n := range inputs {
		if !seen[n] {
			seen[n] = true
			outs = append(outs, n)
		}
	}
	return outs
}

// Оставляет только кратные числу (значению фильтра)
type MultipleFilter int
func (mf MultipleFilter) About() string {
	return fmt.Sprintf("keep multiples of %v", mf)
}
func (mf MultipleFilter) Process(inputs []int) []int {
	outs := make([]int, 0, len(inputs))
	for _, n := range inputs {
		if n%int(mf) == 0 {
			outs = append(outs, n)
		}
	}
	return outs
}

// Одна универсальная функция обработки
func filterAndPrint(fltr Filter, input []int) []int {
	output := fltr.Process(input)
	fmt.Println(fltr.About() + ":\n\t", output)
	return output
}

func main() {
	numbers := []int{12, 7, 21, 12, 12, 26, 25, 21, 30}
	fmt.Println("before filtering:\n\t", numbers)

	filters := []Filter{
		UniqueFilter{},
		MultipleFilter(2),
		MultipleFilter(3),
	}

	for _, fltr := range filters {
		numbers = filterAndPrint(fltr, numbers)
	}
}
```

**Результат выполнения:**

```
before filtering:
	 [12 7 21 12 12 26 25 21 30]
remove duplicate numbers:
	 [12 7 21 26 25 30]
keep multiples of 2:
	 [12 26 30]
keep multiples of 3:
	 [12 30]
```

В этом примере **полиморфизм** позволяет обойтись **одной функцией `filterAndPrint`**,
независимо от конкретного типа фильтра.

Полиморфизм также позволяет разработчику библиотеки:

* определить **экспортируемый интерфейс** и функцию с аргументом этого интерфейсного типа;
* пользователь может реализовать интерфейс в своём типе и передать его в функцию;
* автор библиотеки не обязан знать, **как устроен пользовательский тип**, — важна только реализация интерфейса.

Хотя полиморфизм **не является обязательной возможностью языка**,
альтернативные решения (например, колбэки) зачастую менее выразительны.
Полиморфизм делает код **чистым и элегантным**.

### Рефлексия (Reflection)

Go поддерживает **рефлексию**, позволяющую:

* исследовать типы и значения, хранящиеся в интерфейсах;
* управлять этими значениями в рантайме.

Для этого используется **динамическая информация о типе**,
которая сохраняется внутри интерфейсного значения.

В этой статье **не рассматриваются возможности**, предоставляемые [стандартным пакетом `reflect`](https://golang.org/pkg/reflect/).
Пожалуйста, ознакомьтесь с материалом [**«Рефлексия в Go»**](https://go101.org/article/reflection.html), чтобы узнать, как использовать этот пакет.

Ниже будут описаны **только встроенные средства рефлексии**, доступные в Go.
В языке Go встроенная рефлексия реализуется с помощью
* **утверждение типа (type assertion)**;
* **переключение по типу (`type switch`)**.

#### Утверждение типа (Type Assertion)

В **Go есть четыре основных случая преобразования значений с участием интерфейсов**:

1. **Неинтерфейсное значение → интерфейсное значение**
   (тип должен реализовывать интерфейс)
   ✅ Проверяется на этапе **компиляции**

2. **Интерфейсное значение → другой интерфейсный тип**
   (тип исходного значения должен реализовывать целевой интерфейс)
   ✅ Проверяется **на этапе компиляции**

3. **Интерфейсное значение → неинтерфейсное значение**
   (динамический тип должен совпадать с требуемым)
   ✅ Проверяется **в рантайме**

4. **Интерфейс → интерфейс, когда статически типы не совместимы, но динамический тип реализует целевой интерфейс**
   ✅ Проверяется **в рантайме**

Первые два случая уже были объяснены.
Они оба требуют, чтобы тип исходного значения реализовывал интерфейс целевого значения.
Возможность такого преобразования проверяется на этапе компиляции.

Далее будут рассмотрены два оставшихся случая.
Возможность такого преобразования проверяется во время выполнения,
с помощью синтаксиса, называемого **утверждением типа (type assertion)**.
Фактически, этот синтаксис также применим ко второму случаю преобразования, приведённому выше.

Форма выражения утверждения типа: `i.(T)`,
где `i` — это интерфейсное значение, а `T` —
имя типа или литерал типа. Тип `T` должен быть:

* либо произвольным не-интерфейсным типом,
* либо произвольным интерфейсным типом.

В выражении приведения типа `i.(T)`:

* `i` называется **утверждаемым значением (asserted value)**,
* `T` называется **утверждаемым типом (asserted type)**.

Утверждение типа может быть успешным или неуспешным.

* В случае, когда `T` — это не-интерфейсный тип:
  если динамический тип `i` существует и **совпадает с `T`**,
  то приведение будет успешным;
  в противном случае — неуспешным.
  При успешном приведении результатом будет **копия динамического значения `i`**.
  Такие приведения можно рассматривать как попытки «распаковки» значения.

* В случае, когда `T` — это интерфейсный тип:
  если динамический тип `i` существует и **реализует интерфейс `T`**,
  приведение будет успешным;
  в противном случае — неуспешным.
  При успешном приведении копия динамического значения `i` будет **упакована в значение типа `T`**,
  и это значение будет результатом вычисления приведения.

Если приведение типа неудачно, результатом вычисления будет **нулевое значение** для утверждённого типа.

Согласно указанным правилам, если утверждённое значение в приведении типа — это nil-интерфейс,
то приведение **всегда завершится неудачей**.

В большинстве случаев приведение типа используется как однозначное (single-value) выражение.
Однако, если приведение используется как **единственное выражение** в присваивании,
оно может вернуть **второе, необязательное логическое значение**,
и рассматриваться как многозначное (multi-value) выражение.
Второе логическое значение указывает, успешно ли приведение типа.

Обратите внимание: если приведение неудачно и используется как однозначное выражение (без второго логического значения),
то произойдёт **паника (panic)**.

Пример: использование утверждения типа (утверждённые типы — не-интерфейсные):

```go
package main

import "fmt"

func main() {
	// Компилятор выводит тип 123 как int.
	var x interface{} = 123

	// Случай 1:
	n, ok := x.(int)
	fmt.Println(n, ok) // 123 true
	n = x.(int)
	fmt.Println(n)     // 123

	// Случай 2:
	a, ok := x.(float64)
	fmt.Println(a, ok) // 0 false

	// Случай 3:
	a = x.(float64) // приведёт к панике
}
```

Пример: использование утверждения типа (утверждённые типы — интерфейсные):

```go
package main

import "fmt"

type Writer interface {
	Write(buf []byte) (int, error)
}

type DummyWriter struct{}
func (DummyWriter) Write(buf []byte) (int, error) {
	return len(buf), nil
}

func main() {
	var x interface{} = DummyWriter{}
	var y interface{} = "abc"
	// Сейчас динамический тип y — "string".
	var w Writer
	var ok bool

	// Тип DummyWriter реализует и Writer, и interface{}.
	w, ok = x.(Writer)
	fmt.Println(w, ok) // {} true
	x, ok = w.(interface{})
	fmt.Println(x, ok) // {} true

	// Динамический тип y — "string", он не реализует Writer.
	w, ok = y.(Writer)
	fmt.Println(w, ok) // <nil> false
	w = y.(Writer)     // приведёт к панике
}
```

Фактически, для интерфейсного значения `i` с динамическим типом `T`,
вызов метода `i.m(...)` эквивалентен вызову `i.(T).m(...)`.


Вот **дословный перевод текста**, без добавлений, по структуре оригинала:


### Блок управления `type-switch`

Синтаксис блока `type-switch` может быть самым странным в Go.
Его можно рассматривать как расширенную версию приведения типа (type assertion).
Блок `type-switch` в некотором смысле похож на блок управления `switch-case`.
Он выглядит так:

```go
switch aSimpleStatement; v := x.(type) {
case TypeA:
	...
case TypeB, TypeC:
	...
case nil:
	...
default:
	...
}
```

Часть `aSimpleStatement;` является необязательной в блоке `type-switch`.
`aSimpleStatement` должен быть **простым выражением**.
`x` должен быть значением интерфейсного типа и называется утверждённым значением (asserted value).
`v` называется результатом утверждения (assertion result) и должен присутствовать в форме короткого объявления переменной.

Каждое ключевое слово `case` в блоке `type-switch` может сопровождаться
предопределённым идентификатором `nil` или списком, разделённым запятыми,
состоящим как минимум из одного имени типа или литерала типа.
Ни один из таких элементов (`nil`, имена типов, литералы типов) не должен повторяться в одном и том же блоке `type-switch`.

Если тип, указанный после ключевого слова `case`, не является интерфейсным,
то он **должен реализовывать интерфейсный тип утверждённого значения**.

Вот пример использования блока управления `type-switch`:

```go
package main

import "fmt"

func main() {
	values := []interface{}{
		456, "abc", true, 0.33, int32(789),
		[]int{1, 2, 3}, map[int]bool{}, nil,
	}
	for _, x := range values {
		// Здесь переменная v объявляется один раз, но
		// представляет собой разные переменные в разных ветках.
		switch v := x.(type) {
		case []int: // литерал типа
			// Тип v в этой ветке — "[]int".
			fmt.Println("int slice:", v)
		case string: // одно имя типа
			// Тип v в этой ветке — "string".
			fmt.Println("string:", v)
		case int, float64, int32: // несколько имён типов
			// Тип v в этой ветке — "interface{}",
			// как и у x.
			fmt.Println("number:", v)
		case nil:
			// Тип v — "interface{}",
			// как и у x.
			fmt.Println(v)
		default:
			// Тип v — "interface{}",
			// как и у x.
			fmt.Println("others:", v)
		}
		// Заметь: каждая переменная v в
		// последних трёх ветках — это копия x.
	}
}
```

### Вывод:

```
number: 456
string: abc
others: true
number: 0.33
number: 789
int slice: [1 2 3]
others: map[]
<nil>
```

Приведённый выше пример логически эквивалентен следующему:

```go
package main

import "fmt"

func main() {
	values := []interface{}{
		456, "abc", true, 0.33, int32(789),
		[]int{1, 2, 3}, map[int]bool{}, nil,
	}
	for _, x := range values {
		if v, ok := x.([]int); ok {
			fmt.Println("int slice:", v)
		} else if v, ok := x.(string); ok {
			fmt.Println("string:", v)
		} else if x == nil {
			v := x
			fmt.Println(v)
		} else {
			_, isInt := x.(int)
			_, isFloat64 := x.(float64)
			_, isInt32 := x.(int32)
			if isInt || isFloat64 || isInt32 {
				v := x
				fmt.Println("number:", v)
			} else {
				v := x
				fmt.Println("others:", v)
			}
		}
	}
}
```

Блоки `type-switch` похожи на `switch-case` блоки в нескольких аспектах:

* Как и в `switch-case` блоках, в `type-switch` блоке может быть не более одной ветки `default`.
* Как и в `switch-case`, ветка `default` может быть последней, первой или находиться в середине.
* Как и в `switch-case`, блок `type-switch` может не содержать ни одной ветки,
  тогда он рассматривается как пустая операция (no-op).

Но в отличие от `switch-case`, **инструкция `fallthrough` не может использоваться** внутри веток блока `type-switch`.


Вот **дословный перевод** предоставленного текста:

---

### Подробнее об интерфейсах в Go

#### Сравнения, включающие интерфейсные значения

Существует два случая сравнений, в которых участвуют значения интерфейсного типа:

1. Сравнение между неинтерфейсным значением и интерфейсным значением.
2. Сравнение между двумя интерфейсными значениями.

В первом случае, тип неинтерфейсного значения должен реализовывать интерфейсный тип (предположим, это `I`) интерфейсного значения, чтобы неинтерфейсное значение можно было преобразовать (упаковать) в интерфейсное значение типа `I`.
Это означает, что сравнение между неинтерфейсным и интерфейсным значением может быть преобразовано в сравнение между двумя интерфейсными значениями.
Поэтому далее рассматриваются только сравнения между **двумя интерфейсными значениями**.

Сравнение двух интерфейсных значений на самом деле — это сравнение их **динамических типов** и **динамических значений**.

##### Шаги при сравнении двух интерфейсных значений (через оператор `==`):

1. Если одно из значений — `nil`-интерфейс, то результат сравнения — проверка, является ли второе значение тоже `nil`-интерфейсом.
2. Если динамические типы двух интерфейсных значений **разные**, результат сравнения — `false`.
3. Если динамические типы одинаковые:
   * Если этот тип [**несравнимый**](https://go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-rules), произойдёт **паника**.
   * Иначе результат сравнения — это результат сравнения **самих динамических значений**.

#### Вкратце:

Два интерфейсных значения считаются равными только если выполняется одно из следующих условий:

1. Оба являются `nil`-интерфейсами.
2. Их динамические типы **одинаковы** и **сравнимы**, а их динамические значения **равны**.

По этим правилам, два интерфейсных значения, чьи динамические значения равны `nil`, могут быть **не равны**. Пример:

```go
package main

import "fmt"

func main() {
	var a, b, c interface{} = "abc", 123, "a"+"b"+"c"
	// Пример шага 2.
	fmt.Println(a == b) // false
	// Пример шага 3.
	fmt.Println(a == c) // true

	var x *int = nil
	var y *bool = nil
	var ix, iy interface{} = x, y
	var i interface{} = nil
	// Пример шага 2.
	fmt.Println(ix == iy) // false
	// Пример шага 1.
	fmt.Println(ix == i) // false
	// Пример шага 1.
	fmt.Println(iy == i) // false

	// []int — несравнимый тип
	var s []int = nil
	i = s
	// Пример шага 1.
	fmt.Println(i == nil) // false
	// Пример шага 3.
	fmt.Println(i == i) // приведёт к панике
}
```


### Внутреннее устройство интерфейсных значений

В официальной реализации компилятора/рантайма Go, интерфейсные значения `interface{}` и значения с методами (непустые интерфейсы) имеют **разные внутренние структуры**. Подробности смотри в [value parts](https://golang.design/value-part.html#interface-structure).

---

### Значения `[]T` нельзя напрямую преобразовать в `[]I`, даже если `T` реализует интерфейс `I`

Например, иногда нужно преобразовать значение `[]string` в тип `[]interface{}`.
В отличие от некоторых других языков, в Go это **нельзя сделать напрямую**.
Преобразование нужно выполнять вручную в цикле:

```go
package main

import "fmt"

func main() {
	words := []string{
		"Go", "is", "a", "high",
		"efficient", "language.",
	}

	// Прототип функции fmt.Println:
	// func Println(a ...interface{}) (n int, err error)
	// Поэтому words... нельзя напрямую передать как аргумент.

	// fmt.Println(words...) // не компилируется

	// Преобразуем []string в []interface{}
	iw := make([]interface{}, 0, len(words))
	for _, w := range words {
		iw = append(iw, w)
	}
	fmt.Println(iw...) // работает
}
```

### Каждый метод интерфейса соответствует неявной функции

Для каждого метода `m`, указанного в интерфейсе `I`, компилятор неявно объявляет функцию с именем `I.m`,
которая принимает **на один аргумент больше**, чем метод `m`: этот дополнительный аргумент — значение типа `I`,
и он становится **первым параметром** функции `I.m`.
Если `i` — это значение интерфейса `I`,
то вызов `i.m(...)` эквивалентен вызову `I.m(i, ...)`.

#### Пример:

```go
package main

import "fmt"

type I interface {
	m(int) bool
}

type T string

func (t T) m(n int) bool {
	return len(t) > n
}

func main() {
	var i I = T("gopher")
	fmt.Println(i.m(5))                        // true
	fmt.Println(I.m(i, 5))                     // true
	fmt.Println(interface{m(int)bool}.m(i, 5)) // true

	// Следующие строки компилируются,
	// но вызывают панику во время выполнения:
	I(nil).m(5)
	I.m(nil, 5)
	interface{m(int) bool}.m(nil, 5)
}
```
